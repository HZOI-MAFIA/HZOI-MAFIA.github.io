<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[暑假集训D8总结]]></title>
    <url>%2F2017%2F08%2F01%2F46%2F</url>
    <content type="text"><![CDATA[%dalao今天有两位大佬来讲课，meaty来讲了Catalan（本来说好的莫比乌斯反演呢），聪聪来讲Splay呢至于听课笔记= =，没来得及记= =不过好不想上树啊，上了树就下不来了 考试仍然爆炸= =三道题，45分解题报告：T1 CubeT2 [Poi2014]FarmCraftT3 [ZJOI2007] 报表统计然而考试真的容易炸，找规律都不会，非得想暴搜= = 刷题从OI学麻将强行刷一圈麻将题来学麻将= =，不过还是挺有意思的，毕竟川娃子不学麻将也不太好啊= =最近刷题刷的贼蒙，不知道刷啥，刷任务刷的贼难，随便刷就真的是随便A= =，我。。。 Blog据说我的访问量基本是因为我这儿友链多，好找别人博客2333反正随便写啦，主要也是为了自己看，就像昨天说的： 来者皆是客，无人亦自赏 这种事，说说就好了，我知道的哦= = 生活今天感觉没什么的，不想前两天那么暴躁，也没有什么太喜悦的事平淡也好，毕竟可以在欢声笑语中打出GG（飞龙骑脸怎么输？）不过也就是这样才是生活吧，顺随自然，也没什么不对的 Sing A Song《尘土》——汪峰 爸爸留给我的纸飞机我捏在手里我慢慢的把它拆开漂亮的一张废纸我静静的走到窗边手里握着剪刀我把它剪得粉碎然后挥舞在阳光里 这是多么美好的一天阳光明媚 大地无边我却毫无意义一道倾斜的光柱无话可说 无处不在就像粒尘土 满天飞舞的纸飞机一些不确定的轨迹我不停地揉搓着手臂直到有了温暖的感觉我有些不安和害怕忘了读那废纸上的字迹我不停地挥舞着手臂然后飞舞在阳光里 这是多么美好的一天阳光明媚 大地无边我却毫无意义一道倾斜的光柱无话可说 无处不在就像粒尘土 突然有种失真的感觉那么柔软 那么锋利是谁在大声欢笑我不会哭 就像粒尘土就像粒尘土 狂欢的队伍已经远去我只能看到自己的影子我对着风吹来的方向听我只能听到自己的呼吸我想我再也找不到你就像我从未找到过自己而你从未给过我的东西竟是我的全部生命 这是多么美好的一天阳光明媚 大地无边我却毫无意义一道倾斜的光柱无话可说 无处不在就像粒尘土 突然有种失真的感觉那么柔软 那么锋利是谁在大声欢笑我不会哭 就像粒尘土就像粒尘土就像粒尘土就像粒尘土 我们，都像尘土]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从OI学麻将]]></title>
    <url>%2F2017%2F08%2F01%2F45%2F</url>
    <content type="text"><![CDATA[背景作为一名川娃子，怎么能不懂麻将呢= = T1 さきなに~~[咲 -Saki-] 天才麻将少女什么编 题目二十一世纪，世界上的麻将竞技人数超过一亿，日本每年也有大规模的全国大赛来对麻将选手进行选拔。从小学到高中，很多学校也设立了麻将部。《天才麻将少女阿知贺篇 episode of side-A》『咲 -Saki- 阿知賀編 episode of side-A』是《天才麻将少女》『咲 -Saki-』的外传，从另一个视角讲述麻将少女们的故事。故事背景设定在《天才麻将少女》本篇第二主角原村和曾生活的奈良县，主角校为阿知贺女子学院。（有问题？内事百度，外事谷歌）由于阿知贺人物存在感不够强，导致该作被称为“千里山篇”「怜 -Toki- 千里山編」，甚至 2012 年动画最萌也是千里山的園城寺怜同学。我们一直很疑惑这到底谁是主角，那么就让数据说话吧！ 题目要求我们给出一个人物列表，人物有其所属的学校。比如「松実玄」同学隶属「阿知賀女子学院」什么的。有的人物没有所属学校或没有明确给出其所属，可以无视。人物每一次出场都会给其学校增加一点存在感。有少数“被牌爱着的孩子”，即“魔物”会有非常高的存在感，出场一次会有普通人出场两次的存在感。我们需要统计，在给出的人物出场单中，哪个学校存在感最高，我们就把这篇动画命名为什么编。 INPUT 输入文件第一行为一个整数 n ，表示有多少人物出现。下面 n 行是人物列表，每两行有两个字符串 A 和 B ，表示人物 A 属于学校 B 。没有同名人物，不会重复出现人物。 下面一行一个整数 k ，表示魔物的数量。接下来 k 行，每行一个字符串，表示魔物的姓名，不保证魔物在人物列表中。 接下来直到文件末尾，每行有一个字符串（空行不算），表示出场人物，可能会出现不存在于上面列表中的人物。OUTPUT输出只有一行，即存在感最大的学校名称，并列第一则输出编码序小的一个。SAMPLEINPUT7宮永咲 清澄高校原村和 清澄高校片岡優希 清澄高校園城寺怜 千里山女子高校竹井久 清澄高校天江衣 龍門渕高校龍門渕透華 龍門渕高校2宮永咲天江衣 原村和高鴨穏乃原村和片岡優希原村和宮永咲 OUTPUT清澄高校 解题报告其实T1跟麻将没啥关系= =map与string各种练手就好了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;map&lt;int,string&gt;n_sch;map&lt;string,int&gt;peo;map&lt;string,int&gt;sch;int bl[233];int n,k;string a,b;int cnt;int w[233],sum[233];inline int gg()&#123; freopen("sakinani.in","r",stdin); freopen("sakinani.out","w",stdout); scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; cin&gt;&gt;a&gt;&gt;b; w[i]=1; peo[a]=i; if(!sch[b]) sch[b]=++cnt,n_sch[cnt]=b; bl[i]=sch[b]; &#125; scanf("%d",&amp;k); for(int i=1;i&lt;=k;i++)&#123; cin&gt;&gt;a; if(peo.count(a)) w[peo[a]]=2; &#125; while(cin&gt;&gt;a)&#123; if(!peo.count(a)) continue; sum[bl[peo[a]]]+=w[peo[a]]; &#125; int mx(0),ans; for(int i=1;i&lt;=cnt;i++)&#123; if(sum[i]==mx&amp;&amp;n_sch[i]&lt;n_sch[ans]) ans=i; if(sum[i]&gt;mx) mx=sum[i],ans=i; &#125; cout&lt;&lt;n_sch[ans]; return 0;&#125;int K(gg());int main()&#123;;&#125; T2 简单的麻将[DreamTeam]麻将 题目题目描述：DreamTeam 成员每天晚上的必修课当然是打麻将!可是Geer每次打完都是输(因为她刚学会打麻将,经常瞎和(音胡，意即赢得胜利),该和不和—-输了又要请大家喝奶茶)但是Geer不服输,又仗着自己学了几天编程,自以为不得了!于是她决定遍写一个程序来,提高自己对麻将的熟悉程度!(避免少输点); 不会打麻将的要耽误点时间看了(会打的阴到笑).. 21世纪..还有人不会打麻将(偶5岁就会,第一次帮我爸打了一盘还赢了5元钱…表鄙视我!):麻将总共108张 筒,条,万 分别有4张一样的 1..9如 1筒4张 1条4张 1万4张 2筒4张 2条4张……. 9筒4张 9条4张 9万4张 没了! 3×4×9=108 没错吧!图形：字符：W1 W2 W3 T1 T2 T3 W9 W9 W9 T7 T8 T9 T9 T9 此样例表示已经胡了！！！例如：3个连续的并且都全部属于 万或条或筒 叫做一个 搭子吧 3个一样的 也叫一个搭子吧 要想和牌 还必须有一个对子（就是2个一样的）如上面就是前12张牌就是4个搭子 后面2个9筒叫对子！ 就算和牌了！唯一的特殊情况就是7个对子也算和（巧七对） 注意：要和牌必须4个搭子1个对子或者7个对子！ 开始Geer只有13牌如：样例假如第一张1万开始的时候没有 则刚好13张，你要输出的结果就是他还需要一张什么牌他才能和牌 这样他继可以和1万 也可以和4万 W2：表示2万 T1：表示1筒 D3：表示3条 INPUT13张牌，每张一个空格；（最后那张没空格） OUTPUT如何再需要一张能和牌 输出这张牌的所有可能性（注意空格，输出的结果数字小的写到前面 ） 如果再要一张也不能和牌，则输出“NO!” SAMPLEINPUTW2 W3 T1 T2 T3 W9 W9 W9 T7 T7 T9 T9 T9 OUTPUTW1 W4 解题报告暴搜就好，可以参考一下斗地主显然，没有风牌、箭牌、还有奇奇怪怪的春夏秋冬梅兰竹菊= =，总共只有3×9=27种牌，那么我们枚举这27种牌，看得到它们后能不能和判断的时候暴搜一波，判断一下搭子与巧七对即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int a[5][10],sum[5];char ch[3],ans[5];inline bool qiaoqidui()&#123; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=9;j++) if(a[i][j]&amp;&amp;a[i][j]!=2) return false; return true;&#125;bool vis[5][10];inline void judge(int x,int y)&#123; if(vis[x][y]) return; vis[x][y]=1; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=9;j++) if(a[i][j]) return; printf("%c%d ",ans[x],y);&#125;inline void dfs(int,int,bool,int,int);inline void shun(int col,int sm,bool dui,int x,int y)&#123; for(int i=1;i&lt;=7;i++)&#123; if(a[col][i]&amp;&amp;a[col][i+1]&amp;&amp;a[col][i+2])&#123; a[col][i]--,a[col][i+1]--,a[col][i+2]--; dfs(col,sm-3,dui,x,y); a[col][i]++,a[col][i+1]++,a[col][i+2]++; &#125; &#125;&#125;inline void tri(int col,int sm,bool dui,int x,int y)&#123; for(int i=1;i&lt;=9;i++) if(a[col][i]==3) a[col][i]=0,dfs(col,sm-3,dui,x,y),a[col][i]=3;&#125;inline void du(int col,int sm,bool dui,int x,int y)&#123; for(int i=1;i&lt;=9;i++) if(a[col][i]==2) a[col][i]=0,dfs(col,sm-2,dui,x,y),a[col][i]=2;&#125;inline void dfs(int col,int sm,bool dui,int x,int y)&#123; if(vis[x][y]) return; if(col==4)&#123; judge(x,y); return; &#125; if(!sm)&#123; dfs(col+1,sum[col+1],dui,x,y); return; &#125; if(sm&gt;=3) shun(col,sm,dui,x,y),tri(col,sm,dui,x,y); else if(!dui&amp;&amp;sm&gt;=2) du(col,sm,1,x,y); else return;&#125;inline int gg()&#123; freopen("majiang.in","r",stdin); freopen("majiang.out","w",stdout); ans[1]='W',ans[2]='T',ans[3]='D'; for(int i=1;i&lt;=13;i++)&#123; scanf("%s",ch); if(ch[0]=='W') a[1][ch[1]-'0']++,sum[1]++; if(ch[0]=='T') a[2][ch[1]-'0']++,sum[2]++; if(ch[0]=='D') a[3][ch[1]-'0']++,sum[3]++; &#125; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=9;j++)&#123; a[i][j]++,sum[i]++; if(qiaoqidui())&#123; vis[i][j]=1; printf("%c%d ",ans[i],j); continue; &#125; dfs(1,sum[1],0,i,j); a[i][j]--,sum[i]--; &#125; for(int i=1;i&lt;=3;i++) for(int j=1;j&lt;=9;j++) if(vis[i][j]) return 0; puts("NO!"); return 0;&#125;int K(gg());int main()&#123;;&#125; T3 更强的麻将UVa 11210 Chinese mahjong比T2多了风牌与箭牌，然而还是没有春夏秋冬梅兰竹菊= =由于没有UVa号，就不贴题目与标程了= =（是根本就没有吧啊喂） 总结所以我到底学会没有呢？我猜我是学会了吧= =]]></content>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2007] 报表统计]]></title>
    <url>%2F2017%2F08%2F01%2F44%2F</url>
    <content type="text"><![CDATA[题目传送门小Q的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小Q希望可以帮妈妈分担一些工作，作为她的生日礼物之一。 经过仔细观察，小Q发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。在最开始的时候，有一个长度为N的整数序列，并且有以下三种操作：INSERT i k在原数列的第i个元素后面添加一个新元素k；如果原数列的第i个元素已经添加了若干元素，则添加在这些元素的最后（见下面的例子）MIN_GAP查询相邻两个元素的之间差值（绝对值）的最小值MIN_SORT_GAP查询所有元素中最接近的两个元素的差值（绝对值）例如一开始的序列为5 3 1执行操作INSERT 2 9将得到：5 3 9 1此时MIN_GAP为2，MIN_SORT_GAP为2。再执行操作INSERT 2 6将得到：5 3 9 6 1注意这个时候原序列的第2个元素后面已经添加了一个9，此时添加的6应加在9的后面。这个时候MIN_GAP为2，MIN_SORT_GAP为1。于是小Q写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？ INPUT输入文件form.in第一行包含两个整数N，M，分别表示原数列的长度以及操作的次数。第二行为N个整数，为初始序列。接下来的M行每行一个操作，即“INSERT i k”，“MIN_GAP”，“MIN_SORT_GAP”中的一种（无多余空格或者空行）。 OUTPUT对于每一个“MIN_GAP”和“MIN_SORT_GAP”命令，输出一行答案即可。 SAMPLEINPUT3 55 3 1INSERT 2 9MIN_SORT_GAPINSERT 2 6MIN_GAPMIN_SORT_GAP OUTPUT221 数据规模对于30%的数据，N≤ 1000 , M ≤ 5000对于100%的数据，N , M ≤500000对于所有的数据，序列内的整数不超过5×10^8。 解题报告考试题的加强版，数据大了十倍考试打了个暴力，骗了20分= =正解：STL三件套——vec,que,还有setvector用来存每个位置后面加的元素priority_queue用来存相邻的差值，要用两个，一个存答案，一个用来垃圾回收（为什么要垃圾回收？当我们插入一个数时，我们将两个原本相连的数分开了，那么他们不再相连，所以我们要清理掉它）set用来处理全局最小差，我们可以用set找到一个数的前驱与后驱，而且显然的是，最小差一定存在于排完序后的相邻的数，所以我们可以进行预处理，边插入边更新123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;using namespace std;inline int read()&#123; int sum(0),f(1); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()) if(ch=='-') f=-1; for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum*f;&#125;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;dust;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;ans1;vector&lt;int&gt;v[500002];multiset&lt;int&gt;st;multiset&lt;int&gt;::iterator it;int n,m;int w[500002];int ans2(0x7fffffff);char op[20];inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int jdz(int x)&#123; return x&gt;=0?x:-x;&#125;inline void insert(int x,int y)&#123; int size(v[x].size()); if(x&lt;n) dust.push(jdz(v[x][size-1]-v[x+1][0])); ans1.push(jdz(y-v[x][size-1])); if(x&lt;n) ans1.push(jdz(y-v[x+1][0])); v[x].push_back(y); st.insert(y); it=st.find(y); if(it!=st.begin())&#123; it--; int tmp(*it); ans2=my_min(jdz(y-tmp),ans2); it++; &#125; if(it!=st.end())&#123; it++; int tmp(*it); ans2=my_min(jdz(y-tmp),ans2); &#125;&#125;inline int query()&#123; while(1)&#123; if(dust.empty()||dust.top()!=ans1.top()) break; dust.pop(); ans1.pop(); &#125; return ans1.top();&#125;int main()&#123; freopen("form.in","r",stdin); freopen("form.out","w",stdout); n=read(),m=read(); for(int i=1;i&lt;=n;i++)&#123; w[i]=read(); st.insert(w[i]); it=st.find(w[i]); if(it!=st.begin())&#123; it--; int tmp(*it); ans2=my_min(ans2,jdz(tmp-w[i])); it++; &#125; if(it!=st.end())&#123; it++; int tmp(*it);//cout&lt;&lt;tmp&lt;&lt;endl; ans2=my_min(ans2,jdz(tmp-w[i])); &#125; if(i^1) ans1.push(jdz(w[i]-w[i-1])); v[i].push_back(w[i]);// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;w[i]&lt;&lt;' '&lt;&lt;ans2&lt;&lt;endl; &#125; while(m--)&#123; scanf("%s",op); if(op[0]=='I')&#123; int x(read()),y(read()); insert(x,y); &#125; else&#123; if(strlen(op)&lt;9) printf("%d\n",query()); else printf("%d\n",ans2); &#125; &#125;&#125; 好强大的STL啊= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Poi2014]FarmCraft]]></title>
    <url>%2F2017%2F08%2F01%2F43%2F</url>
    <content type="text"><![CDATA[题目mhy住在一棵有n个点的树的1号结点上，每个结点上都有一个妹子。mhy从自己家出发，去给每一个妹子都送一台电脑，每个妹子拿到电脑后就会开始安装zhx牌杀毒软件，第i个妹子安装时间为Ci。树上的每条边mhy能且仅能走两次，每次耗费1单位时间。mhy送完所有电脑后会回自己家里然后开始装zhx牌杀毒软件。卸货和装电脑是不需要时间的。求所有妹子和mhy都装好zhx牌杀毒软件的最短时间。 INPUT第一行输入一个整数N，表示有N个结点第二行有N个整数C1,C2…Cn，Ci表示第i个妹子安装杀毒软件的时间接下来的N-1行，每行两个整数x，y，表示x与y之间有一条无向边 OUTPUT输出文件仅包含一行，一个整数表示让所有妹子和mhy装好杀毒软件的最短时间 SAMPLEINPUT61 8 9 6 3 21 32 33 44 54 6 OUTPUT11 解题报告翻译真累= =，原题英文版，结果发现翻译跟英文啥关系没有，就粘了翻译，然后发现输入格式跟输出格式都没有翻译，然后= =，然后我就强行翻译了一发= =考试时打了个dfs，骗了5分- -正解：贪心。我们分析题干，发现每条边只能过两次，也就是一进一出，那么我们进了一个点，我们就要遍历完整个子树，所以我们只能跑一遍dfs，然后我们发现dfs一遍的时间是一定的，那么见每个妹子的时间就在这个时间轴上。我们定义一个数组rest，代表遍历完这个节店的子树，以后我们还要为这个节点所费的时间。 除了1节点，见到一个妹子杀一下毒 我们发现答案是Max(rest[1],c[1])+2×(n-1) 我们考虑如何找rest，我们发现，每个节点的最优rest是 子节点的rest，减去其在这个子树里又经过的时间 再和 它的c减去遍历它的时间 取个Max 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;int n;int w[500001];int fa[500001],t[500001],rest[500001];inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;vector&lt;int&gt;g[500001];inline bool cmp(const int &amp;a,const int &amp;b)&#123; return rest[a]&gt;rest[b];&#125;inline void dfs(int u)&#123; int size(g[u].size()); for(int i=0;i&lt;size;i++)&#123; int e(g[u][i]); if(e!=fa[u])&#123; t[u]++; fa[e]=u; dfs(e); t[u]++; t[u]+=t[e]; &#125; &#125; if(u!=1) rest[u]=w[u]-t[u]; int tmp(t[u]); sort(g[u].begin(),g[u].end(),cmp); for(int i=0;i&lt;size;i++)&#123; int e(g[u][i]); if(e!=fa[u])&#123; tmp-=2+t[e]; rest[u]=my_max(rest[u],rest[e]-tmp-1); &#125; &#125; rest[u]=my_max(0,rest[u]);// cout&lt;&lt;u&lt;&lt;' '&lt;&lt;w[u]&lt;&lt;' '&lt;&lt;rest[u]&lt;&lt;endl;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); for(int i=1;i&lt;n;i++)&#123; int x(read()),y(read()); g[x].push_back(y),g[y].push_back(x); &#125; dfs(1); printf("%d",my_max(rest[1],w[1])+(n&lt;&lt;1)-2);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cube]]></title>
    <url>%2F2017%2F08%2F01%2F42%2F</url>
    <content type="text"><![CDATA[题目给你一个n×m的棋盘，有一个1×1×2的长方体竖直放在(1,1)上，你可以将其在棋盘上滚动，你的目标是让其竖直放在(n,m)上，问至少需要多少次操作。(放倒、竖直、翻滚) INPUT一行，两个整数n，m (n&lt;=m) OUTPUT需要最少时间逃脱密室。若无解输出impossible。 SAMPLEINPUT11 1 OUTPUT10 INPUT22 4 OUTPUT23 INPUT34 7 OUTPUT36 解题报告看到“逃离密室”这四个字我是蒙的= =，（哪里提到密室了啊喂）考试时就打了个n=1~3的特判，结果3还没打对= =正解：显然可以找规律。n=1或2时，因为方块无法立起来在较小一维翻滚，所以只有1和2存在“impossible”情况，那么我们只需判断m与3的整除关系，显然只有(m-1)%3==0时才可能正好立起来到达终点，且步数为((m-1)/3)×2。如果n=2，还需加上方块横着滚一次的次数n=3时最为特殊，因为方块可以通过各种奇怪的方法翻转，来达到立起来到达终点的结果，原因是因为n=3时，方块可以通过多次横滚加一次立起换向的方式达到效果，所以我们可以得到这样的式子： ans=4+((m-1)/3)×2+(m-1)%3 然而我们需要注意3×3的情况，答案为8，我就不证了（不会证），其实自己画个图，翻两下就可以了接下来是大部分的情况，我们考虑一个4×4的网格，显然，我们竖着操作两遍，横着操作两遍即可，那么就很简单了，假设我们加了一列，成了4×5，我们只需多横滚一次即可，所以很容易得出式子： ans=((n-1)/3+(m-1)/3+(n-1)%3+(m-1)%3)×2 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int ans(0);int main()&#123; scanf("%d%d",&amp;n,&amp;m); if(n==1||n==2)&#123; if((m-1)%3)&#123; puts("impossible"); return 0; &#125; printf("%d",(((m-1)/3)&lt;&lt;1)+n-1); return 0; &#125; if(n==3)&#123; if(m==3)&#123; puts("8"); return 0; &#125; ans=2; ans+=((m-1)/3)&lt;&lt;1; if((m-1)%3) ans+=2+(m-1)%3; printf("%d",ans); return 0; &#125; ans+=((n-1)/3)&lt;&lt;1;//cout&lt;&lt;ans&lt;&lt;endl; ans+=(n-1)%3;//cout&lt;&lt;ans&lt;&lt;endl; ans+=((m-1)/3)&lt;&lt;1;//cout&lt;&lt;ans&lt;&lt;endl; ans+=(m-1)%3;//cout&lt;&lt;ans&lt;&lt;endl; printf("%d",ans);&#125; 我考试时竟然想了暴搜，我也是服我自己= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COGS426 血帆海盗]]></title>
    <url>%2F2017%2F07%2F31%2F41%2F</url>
    <content type="text"><![CDATA[题目传送门随着资本的扩大，藏宝海湾贸易亲王在卡利姆多和东部王国大陆各建立了N/2 个港口。大灾变发生以后，这些港口之间失去了联系，相继脱离了藏宝海湾贸易亲王的管辖，各自为政。利益的驱动使得每个港口都想和对岸大陆的另一个港口建立贸易合作关系，由于地理位置因素，只有存在直接到达的航线的两个港口才能建立合作，而且每个港口只与对岸一个港口建立合作，因此并不是所有的港口都能找到合作伙伴。 血帆海盗得知这一消息以后，决定对其中一条航线进行干扰性的掠夺。经过分析，血帆海盗计算出最多能有W 对港口合作。如果两个港口之间只有一条航线，而且这条航线恰好是血帆海盗要掠夺的航线，这两个港口将不能建立合作关系。血帆海盗指挥官菲尔拉伦想知道他们有几种选择，可以让地精们无法建立W 对港口。 INPUT第1行，两个整数N,M，表示一共的港口个数和航线条数。接下来M行，每行两个整数A,B，表示卡利姆多的港口A与东部王国的港口B之间有一条航线直接连接，其中1&lt;=A&lt;=N/2，N/2+1&lt;=B&lt;=N。 OUTPUT一个整数，表示血帆海盗可以选择掠夺的航线条数。 解释：如果掠夺一条航线以后，地精依然可以建立起最多的W个合作关系（可以有多种），那么这条航线是不值得掠夺的，否则就是掠夺方案之一。 SAMPLEINPUT8 51 51 62 73 74 8 OUTPUT1 解题报告好难啊= =，在编译器炸了的情况下生交了3遍，然后各种编译错误加不过样例= = 最小割的唯一性判定在残余网络上跑tarjan求出所有SCC，记id[u]为点u所在SCC的编号。显然有id[s]!=id[t]（否则s到t有通路，能继续增广）。①对于任意一条满流边(u,v)，(u,v)能够出现在某个最小割集中，当且仅当id[u]!=id[v]；②对于任意一条满流边(u,v)，(u,v)必定出现在最小割集中，当且仅当id[u]==id[s]且id[v]==id[t]。①&lt;==将每个SCC缩成一个点，得到的新图就只含有满流边了。那么新图的任一s-t割都对应原图的某个最小割，从中任取一个把id[u]和id[v]割开的割即可证明。②&lt;==：假设将(u,v)的边权增大，那么残余网络中会出现s-&gt;u-&gt;v-&gt;t的通路，从而能继续增广，于是最大流流量（也就是最小割容量）会增大。这即说明(u,v)是最小割集中必须出现的边。 然后就可以跑了= =123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[400005];int pre[100005],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m;int ed;int S(0),T;int ans(0),inf(0x7fffffff);int dis[100005];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125;inline void dinic(int s,int t)&#123; while(bfs(s,t)) ans+=dfs(s,inf);&#125;int dfn[100005],low[100005],bl[100005],stack[100005];int qlt,cnt,top;bool vis[100005];inline void tarjan(int u)&#123; dfn[u]=low[u]=++cnt; stack[++top]=u; vis[u]=1; for(int i=pre[u];i!=-1;i=a[i].n) if(a[i].w)&#123; int e(a[i].e); if(!dfn[e])&#123; tarjan(e); low[u]=my_min(low[u],low[e]); &#125; else if(vis[e]) low[u]=my_min(low[u],dfn[e]); &#125; if(low[u]==dfn[u])&#123; qlt++; while(1)&#123; int tmp(stack[top--]); vis[tmp]=0; bl[tmp]=qlt; if(tmp==u) break; &#125; &#125;&#125;inline int gg()&#123; freopen("bloodsail.in","r",stdin); freopen("bloodsail.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); ed=n&gt;&gt;1; T=n+1; for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); insert(x,y,1),insert(y,x,0); &#125; for(int i=1;i&lt;=ed;i++) insert(S,i,1),insert(i,S,0),insert(i+ed,T,1),insert(T,i+ed,0); dinic(S,T);//cout&lt;&lt;ans&lt;&lt;endl; for(int i=0;i&lt;=n+1;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=ed;i++) for(int j=pre[i];j!=-1;j=a[j].n) if(!a[j].w&amp;&amp;bl[i]==bl[a[j].e]&amp;&amp;a[j].e) ans--; printf("%d",ans); return 0;&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D7总结]]></title>
    <url>%2F2017%2F07%2F31%2F40%2F</url>
    <content type="text"><![CDATA[刷题上午刷了一上午的网络流 （md建图快建吐了），然后就搞了一个网络流的索引= = （实在看不下去那篇大长文了啊喂），然后发现都是水题= =，我还瞎××乱刷下午——听说我要刷平衡树？ Blog日常乱搞blog，扔了一大圈网络流水题上去，然后就开始搞百度，（mdzz百度爬虫爬不到github），然后发现可能我的库炸掉了，于是愤怒的放弃了百度计划- -然后正当我准备让我的博客回溯回到原来的状态时，我发现我的库炸飞了，然后叫来某司机，某司机进行了一圈令人窒息的操作，我的库又回来啦 （mdzz我又创了个新库）所以现在我的博客几乎是不可描述的- - 新大陆？闲得无聊在洛谷开了个新号，然后瞎××刷了几道水题，比如A+B Problem什么的普通平衡树真难打，然后就没有然后了。现在就准备去搜罗一圈，看能不能像在COGS上一样搞下来点军（tu）火（bao）什么的= = 生活日常烦躁 blog差点炸掉 （虽然是日常），百度仍然不知道在干什么地不给过站长验证 （说好的2~3min的反馈等了一下午都没回复，要不是几乎所有人都用这破玩意儿，我就不搞它了），U盘还被设权限 （我tm连Everyone的权限都没有？搞笑？），刷题日常没心情，只能瞎××刷点 （本来好不容易说要来个小联赛，生被怼下去，我也是服了） 然后，我马上就码好的这篇总结，生被某司机强行手贱关机给干掉了 （马上就完成了好吗，我tm心累啊）最后只能在欢声笑语中打出GG？ 歌《Guts Over Fear》——Eminem&amp;Sia I was afraid to make a single soundAfraid I’ll never find a way out out outAfraid I’ll never before IAn angry man’s power will shut you upTrip wires in this house will cut our loveRun out of excuses for every wordSo here I am,I will not runGuts over fearThe time is hereGuts over fearI shall not tearFor all the time I let you push me around and let you kick me downNow I gotGuts over fearGuts over fear Feel like a closeIt’s coming toFuckin’ am IGonna doIt’s a little late to start overThis is the only thing I,thing I know]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[从入门到放弃]——网络流 学习索引]]></title>
    <url>%2F2017%2F07%2F31%2F39%2F</url>
    <content type="text"><![CDATA[前篇由于某篇博文已经长到我自己看不下去的地步，又不忍心删，所以就有了这篇索引，方便自己找，也方便来访的客人看嘛（真的会有人来看吗啊喂） 最长的博文2017-7-29 大佬讲课笔记 网络流——从入门到放弃没错，就是它= = 各种题解的索引搭配飞行员士兵占领王者之剑happiness切糕餐巾血帆海盗]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[餐巾]]></title>
    <url>%2F2017%2F07%2F31%2F38%2F</url>
    <content type="text"><![CDATA[题目传送门一个餐厅在相继的N天里，第i天需要Ri块餐巾(i=l，2，…，N)。餐厅可以从三种途径获得餐巾。(1)购买新的餐巾，每块需p分；(2)把用过的餐巾送到快洗部，洗一块需m天，费用需f分(fm)，费用需s分(s&lt;f)。在每天结束时，餐厅必须决定多少块用过的餐巾送到快洗部，多少块送慢洗部。在每天开始时，餐厅必须决定是否购买新餐巾及多少，使洗好的和新购的餐巾之和满足当天的需求量Ri，并使N天总的费用最小。 INPUT输入文件共 3 行，第 1 行为总天数；第 2 行为每天所需的餐巾块数；第 3 行为每块餐巾的新购费用 p ，快洗所需天数 m ，快洗所需费用 f ，慢洗所需天数 n ，慢洗所需费用 s 。 OUTPUT一行，最小的费用 SAMPLEINPUT33 2 410 1 6 2 3 OUTPUT64 解题报告首先，每天的餐巾分为两种情况，新买的和原来的。每天作为一个点，由S向其连边，容量为Ri，花费为0。每天可以向T连边，容量为INF，花费为p，每天都可以购买餐巾无数次。将每天用过的餐巾在新建一层点，由于分配去快洗和慢洗的餐巾总数有限制，并非分别有限制，所有这两种无需再分开，这层点分别向T建边，容量为Ri，花费为0，限制总容量。使用快洗的餐巾，由i向(i+m+N)’建边，容量为INF，花费为f，慢洗同理，花费分别建边。但第i-m天洗完后的餐巾也可以供第i天以后使用。所以再由i向i+1建边，容量为INF，花费为0。这样第i天就能使用到以前所有可以使用的洗完的餐巾了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct edge&#123; int e,n,flow,cost;&#125;a[20010];int pre[410],tot;inline void insert(int s,int e,int flow,int cost)&#123; a[tot].e=e; a[tot].flow=flow; a[tot].cost=cost; a[tot].n=pre[s]; pre[s]=tot++;&#125;int S(0),T;int N,p,m,f,n,s;int r[201];int flow(0),ans(0),inf(0x7fffffff);inline void build()&#123; for(int i=1;i&lt;=N;i++)&#123; insert(S,i,r[i],0),insert(i,S,0,0); insert(S,i+N,inf,p),insert(i+N,S,0,-p); insert(i+N,T,r[i],0),insert(T,i+N,0,0); if(i+m&lt;=N) insert(i,i+m+N,inf,f),insert(i+m+N,i,0,-f); if(i+n&lt;=N) insert(i,i+n+N,inf,s),insert(i+n+N,i,0,-s); if(i!=N) insert(i,i+1,inf,0),insert(i+1,i,0,0); &#125;&#125;int dis[410],fa[410],path[410];inline bool bfs()&#123; memset(dis,30,sizeof(dis)); memset(fa,-1,sizeof(fa)); queue&lt;int&gt;q; q.push(S); dis[S]=0; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(a[i].flow&amp;&amp;dis[e]&gt;dis[k]+a[i].cost)&#123; dis[e]=dis[k]+a[i].cost; fa[e]=k; path[e]=i; q.push(e); &#125; &#125; &#125; if(fa[T]==-1) return false; return true;&#125;inline void dinic()&#123; while(bfs())&#123; int f(inf); for(int i=T;i!=S;i=fa[i]) if(a[path[i]].flow&lt;f) f=a[path[i]].flow; flow+=f; ans+=dis[T]*f; for(int i=T;i!=S;i=fa[i])&#123; a[path[i]].flow-=f; a[path[i]^1].flow+=f; &#125; &#125;&#125;inline int gg()&#123; freopen("napkin.in","r",stdin); freopen("napkin.out","w",stdout); memset(pre,-1,sizeof(pre)); scanf("%d",&amp;N); T=(N&lt;&lt;1)+1; for(int i=1;i&lt;=N;i++) scanf("%d",&amp;r[i]); scanf("%d%d%d%d%d",&amp;p,&amp;m,&amp;f,&amp;n,&amp;s); build(); dinic(); printf("%d",ans); return 0;&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切糕]]></title>
    <url>%2F2017%2F07%2F31%2F37%2F</url>
    <content type="text"><![CDATA[题目传送门经过千辛万苦小A 得到了一块切糕，切糕的形状是长方体，小A 打算拦腰将切糕切成两半分给小B。出于美观考虑，小A 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。出于简便考虑，我们将切糕视作一个长P、宽Q、高R 的长方体点阵。我们将位于第z层中第x 行、第y 列上(1≤x≤P, 1≤y≤Q, 1≤z≤R)的点称为(x,y,z)，它有一个非负的不和谐值v(x,y,z)。一个合法的切面满足以下两个条件： 与每个纵轴(一共有P×Q 个纵轴)有且仅有一个交点。即切面是一个函数f(x,y)，对于所有1≤x≤P, 1≤y≤Q,我们需指定一个切割点f(x,y),且1≤f(x,y)≤R。 切面需要满足一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有的1≤x,x’≤P 和1≤y,y’ ≤Q，若|x-x’|+|y-y’|=1，则|f(x,y)-f(x’,y’)| ≤D，其中D 是给定的一个非负整数。 可能有许多切面f 满足上面的条件，小A 希望找出总的切割点上的不和谐值最小的那个，即v(x, y, f (x, y))x,y最小。 INPUT从文件input.txt中读入数据，输入文件第一行是三个正整数P,Q,R，表示切糕的长P、宽Q、高R。第二行有一个非负整数D，表示光滑性要求。接下来是R个P行Q列的矩阵，第z个矩阵的第x行第y列是v(x,y,z) (1≤x≤P,1≤y≤Q, 1≤z≤R)。100%的数据满足P,Q,R≤40，0≤D≤R，且给出的所有的不和谐值不超过1000。 OUTPUT输出文件output.txt 仅包含一个整数，表示在合法基础上最小的总不和谐值。 SAMPLEINPUT12 2 216 16 12 62 6 OUTPUT16 INPUT22 2 205 15 12 52 5 OUTPUT212 EXPLAIN第一组样例中最佳切面的f为f(1,1)=f(2,1)=2,f(1,2)=f(2,2)=1。第二组样例中最佳切面的f为f(1,1)=f(2,1)=f(1,2)=f(2,2)=1。 解题报告极其 （！@#） 的一道题，反正我在建边时蒙成了 （！@#）。由题意得知，显然为最小割模型，将点权转化为边权。由S向(x,y,1)连边，边权为v(x, y,1)。由(x, y, z)向(x, y, z+1)连边，边权为v(x, y, z+1)。最后由(x, y, R)向T连边，边权为INF。此题关键为这个选择的距离限制。我们可以这样解决：由每个点向它相邻的点的下方的第d个点连边。也就由(x, y, z)向(x, y, z-d)连边，边权为INF。首先，假设每条纵轴只割一条边。若两条边的距离大于d，一定会有图中所示路径，此时仍需要再割一条边。假设再割一条右侧的边，此边与左边割掉的那条边的距离要 ≤ d，否则还会出现这样的路径。只有距离 ≤ d，才能截断。但此时，右边第一次截断的边已经没有必要了。因为只要上面两条边就可以截断了。因此，每个纵轴只截断一条边，且相邻截断的边距离一定 ≤ d。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[1000001];int pre[64500],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int p,q,r,d;int id[41][41][41],w[41][41][41];int cnt(0);int S(0),T;int ans(0),inf(0x7fffffff);int dis[64500];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125;inline int gg()&#123; freopen("nutcake.in","r",stdin); freopen("nutcake.out","w",stdout); memset(pre,-1,sizeof(pre)); p=read(),q=read(),r=read(),d=read(); T=p*q*r+1; for(int i=1;i&lt;=r;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=q;k++)&#123; w[i][j][k]=read(); id[i][j][k]=++cnt; insert(id[i-1][j][k],id[i][j][k],w[i][j][k]),insert(id[i][j][k],id[i-1][j][k],0); if(i==r) insert(id[i][j][k],T,inf),insert(T,id[i][j][k],0); if(i&gt;d)&#123; if(j!=1) insert(id[i][j][k],id[i-d][j-1][k],inf),insert(id[i-d][j-1][k],id[i][j][k],0); if(j!=p) insert(id[i][j][k],id[i-d][j+1][k],inf),insert(id[i-d][j+1][k],id[i][j][k],0); if(k!=1) insert(id[i][j][k],id[i-d][j][k-1],inf),insert(id[i-d][j][k-1],id[i][j][k],0); if(k!=q) insert(id[i][j][k],id[i-d][j][k+1],inf),insert(id[i-d][j][k+1],id[i][j][k],0); &#125; &#125; while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",ans); return 0;&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[happiness]]></title>
    <url>%2F2017%2F07%2F31%2F36%2F</url>
    <content type="text"><![CDATA[题目传送门高一一班的座位表是个n×m的矩阵，经过一个学期的相处，每个同学和前后左右相邻的同学互相成为了好朋友。这学期要分文理科了，每个同学对于选择文科与理科有着自己的喜悦值，而一对好朋友如果能同时选文科或者理科，那么他们又将收获一些喜悦值。作为计算机竞赛教练的scp大老板，想知道如何分配可以使得全班的喜悦值总和最大。 INPUT第一行两个正整数n，m。接下来是六个矩阵第一个矩阵为n行m列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学选择文科获得的喜悦值。第二个矩阵为n行m列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学选择理科获得的喜悦值。第三个矩阵为n-1行m列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学与第i+1行第j列的同学同时选择文科获得的额外喜悦值。第四个矩阵为n-1行m列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学与第i+1行第j列的同学同时选择理科获得的额外喜悦值。第五个矩阵为n行m-1列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学与第i行第j+1列的同学同时选择文科获得的额外喜悦值。第六个矩阵为n行m-1列 此矩阵的第i行第j列的数字表示座位在第i行第j列的同学与第i行第j+1列的同学同时选择理科获得的额外喜悦值。 OUTPUT输出一个整数，表示喜悦值总和的最大值 SAMPLEINPUT1 21 1100 11011000 OUTPUT1210 解题报告选择不同时不能得到额外的权值，所以源点对所有点来说都是文科，汇点对所有点来说都是理科。对于单独两个点来说，只有两种情况。若两个人都选文科，需要割掉第2，4条边，代价为两个人选理科分别的贡献，以及他们一起选理科的贡献，因为所有的点都是等价的，2，4边的权值除各自选理科贡献外再加上一半的额外贡献。若两个人都选择理科同理。若两个人选择不同，假设x选择文科，y选择理科，那么需要割掉2，3，5。此时2，3权值和为分别选择科目的贡献和一半的同时选择理科和同时选择文科的贡献。还需再减去剩余的一半，即应是5的权值。(x，y间要建双向边。)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[200001];int pre[10010],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m;int w[101][101],l[101][101];int jz1[101][101],jz2[101][101],jz3[101][101],jz4[101][101];int sum(0),ans(0),inf(0x7fffffff);int S(0),T;int id[101][101];inline void init()&#123; freopen("nt2011_happiness.in","r",stdin); freopen("nt2011_happiness.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); T=n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read()&lt;&lt;1,sum+=w[i][j]&gt;&gt;1,id[i][j]=(i-1)*m+j; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) l[i][j]=read()&lt;&lt;1,sum+=l[i][j]&gt;&gt;1; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) jz1[i][j]=read(),sum+=jz1[i][j]; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) jz2[i][j]=read(),sum+=jz2[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++) jz3[i][j]=read(),sum+=jz3[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++) jz4[i][j]=read(),sum+=jz4[i][j];&#125;inline void build()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; insert(S,id[i][j],w[i][j]+jz1[i][j]+jz1[i-1][j]+jz3[i][j]+jz3[i][j-1]),insert(id[i][j],S,0); insert(id[i][j],T,l[i][j]+jz2[i][j]+jz2[i-1][j]+jz4[i][j]+jz4[i][j-1]),insert(T,id[i][j],0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(i!=n) insert(id[i][j],id[i][j]+m,jz1[i][j]+jz2[i][j]),insert(id[i][j]+m,id[i][j],jz1[i][j]+jz2[i][j]); if(j!=m) insert(id[i][j],id[i][j]+1,jz3[i][j]+jz4[i][j]),insert(id[i][j]+1,id[i][j],jz3[i][j]+jz4[i][j]); &#125;&#125;int dis[10020];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125;inline void dinic()&#123; while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",sum-(ans&gt;&gt;1));&#125;inline int gg()&#123; init(); build(); dinic(); return 0;&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王者之剑]]></title>
    <url>%2F2017%2F07%2F31%2F35%2F</url>
    <content type="text"><![CDATA[题目传送门这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。宝石排列在一个n×m的网格中，每个网格中有一块价值为v(i,j)的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。开始时刻为0秒。以下操作，每秒按顺序执行1.在第i秒开始的时候，阿尔托利亚·潘德拉贡在方格（x,y）上，她可以拿走（x，y）中的宝石。2.在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失3.若阿尔托利亚·潘德拉贡第i秒开始时在方格（x，y）上，则在第i+1秒可以立即移动到（x+1，y），（x，y+1），（x-1，y）或（x，y-1）上，也可以停留在（x,y)上。求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石 INPUT第一行给出数字N,M代表行列数.N,M均小于等于100，宝石的价值不会超过10000.下面N行M列用于描述数字矩阵 OUTPUT输出最多可以拿到多少价值宝石 SAMPLEINPUT2 21 22 1 OUTPUT4 解题报告算是基础的最小割问题。首先，我们取值时一定是在偶数时刻，取走一个格子的值，就不能取相邻格子的值，也就是相邻格子之间的值是不相容的。我们想，只要取得格子相容，是一定有合法路径的，有不容的点就转化到最小割上，用总值减去割掉最小的值，就是最优解。那么我们可以黑白染色，源点与白点相连，黑点与汇点连边，不相容的点之间连边，容量INF，跑最小割即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[2000001];int pre[100001],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m;int w[105][105],col[105][105];inline void paint()&#123; int now(1); for(int i=1;i&lt;=n;i++)&#123; now^=1; for(int j=1;j&lt;=m;j++)&#123; if(j&amp;1) col[i][j]=now; else col[i][j]=now^1; &#125; &#125;&#125;int S(0),T;int ans(0),inf(0x7fffffff),sum(0);inline void build()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(col[i][j]) insert(S,(i-1)*m+j,w[i][j]),insert((i-1)*m+j,S,0); else insert((i-1)*m+j,T,w[i][j]),insert(T,(i-1)*m+j,0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(col[i][j])&#123; if(i!=1) insert((i-2)*m+j,(i-1)*m+j,0),insert((i-1)*m+j,(i-2)*m+j,inf); if(i!=n) insert(i*m+j,(i-1)*m+j,0),insert((i-1)*m+j,i*m+j,inf); if(j!=1) insert((i-1)*m+j-1,(i-1)*m+j,0),insert((i-1)*m+j,(i-1)*m+j-1,inf); if(j!=m) insert((i-1)*m+j+1,(i-1)*m+j,0),insert((i-1)*m+j,(i-1)*m+j+1,inf); &#125; &#125;&#125;int dis[10010];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125; inline int gg()&#123; freopen("Excalibur.in","r",stdin); freopen("Excalibur.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); T=n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read(),sum+=w[i][j]; paint(); build(); while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",sum-ans); return 0;&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[士兵占领]]></title>
    <url>%2F2017%2F07%2F31%2F34%2F</url>
    <content type="text"><![CDATA[题目传送门有一个M * N的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。我们称这些士兵占领了整个棋盘当满足第i行至少放置了Li个士兵, 第j列至少放置了Cj个士兵。现在你的任务是要求使用最少个数的士兵来占领整个棋盘。 INPUT第一行两个数M, N, K分别表示棋盘的行数，列数以及障碍的个数。 第二行有M个数表示Li。 第三行有N个数表示Ci。 接下来有K行，每行两个数X, Y表示(X, Y)这个格子是障碍。 OUTPUT输出一个数表示最少需要使用的士兵个数。如果无论放置多少个士兵都没有办法占领整个棋盘，输出”JIONG!” (不含引号) SAMPLEINPUT4 4 41 1 1 10 1 0 31 42 23 34 3 OUTPUT4 解题报告也是很裸的网络流，所有行与源点连边，容量为Li，所有列与汇点连边，容量为Ci，可以放士兵的格子对应的行和列连边，跑最大流即为答案要注意的是：点的坐标与数组大小的问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+ch-'0',ch=getchar()); return sum;&#125;struct edge&#123; int s,e,w,n;&#125;a[50001];int pre[250],tot;inline void insert(int s,int e,int w)&#123; a[tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m,k;int sup;int l[101],c[101];bool g[101][101];int sum(0);int dis[301];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; if(!a[i].w||dis[a[i].e]) continue; dis[a[i].e]=dis[k]+1; if(a[i].e==t) return true; q.push(a[i].e); &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==sup) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; if(!a[i].w||!tmp||dis[a[i].e]!=dis[now]+1) continue; f=dfs(a[i].e,my_min(a[i].w,tmp)); if(!f)&#123; dis[a[i].e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; return flow-tmp;&#125;inline bool judge()&#123; int tmp; for(int i=1;i&lt;=m;i++)&#123; tmp=0; for(int j=1;j&lt;=n;j++) if(g[i][j]) tmp++; if(tmp&lt;l[i]) return true; &#125; for(int j=1;j&lt;=n;j++)&#123; tmp=0; for(int i=1;i&lt;=m;i++) if(g[i][j]) tmp++; if(tmp&lt;c[j]) return true; &#125; return false;&#125;int ans(0),inf(0x7fffffff);int main()&#123; memset(pre,-1,sizeof(pre)); memset(g,true,sizeof(g)); m=read(),n=read(),k=read(); sup=n+m+1; for(int i=1;i&lt;=m;i++) l[i]=read(),sum+=l[i]; for(int i=1;i&lt;=n;i++) c[i]=read(),sum+=c[i]; for(int i=1;i&lt;=k;i++)&#123; int x(read()),y(read()); g[x][y]=0; &#125; if(judge())&#123; puts("JIONG!"); return 0; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(g[i][j]) insert(i,j+m,1),insert(j+m,i,0); for(int i=1;i&lt;=m;i++) insert(0,i,l[i]),insert(i,0,0); for(int i=1;i&lt;=n;i++) insert(i+m,sup,c[i]),insert(sup,i+m,0); while(bfs(0,sup)) ans+=dfs(0,inf); printf("%d",sum-ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭配飞行员]]></title>
    <url>%2F2017%2F07%2F31%2F33%2F</url>
    <content type="text"><![CDATA[题目传送门飞行大队有若干个来自各地的驾驶员，专门驾驶一种型号的飞机，这种飞机每架有两个驾驶员,需一个正驾驶员和一个副驾驶员。由于种种原因，例如相互配合的问题，有些驾驶员不能在同一架飞机上飞行，问如何搭配驾驶员才能使出航的飞机最多。假设有10个驾驶员，V1，V2，…，V10就代表达10个驾驶员,其中V1，V2，V3，V4，V5是正驾驶员,V6，V7，V8，V9，V10是副驾驶员。如果一个正驾驶员和一个副驾驶员可以同机飞行，就在代表他们两个之间连一条线,两个人不能同机飞行，就不连。例如V1和V7可以同机飞行，而V1和V8就不行。请搭配飞行员，使出航的飞机最多。注意:因为驾驶工作分工严格,两个正驾驶员或两个副驾驶员都不能同机飞行. INPUT输入文件有若干行第一行，两个整数n与n1，表示共有n个飞行员(2&lt;=n&lt;=100),其中有n1名飞行员是正驾驶员.下面有若干行,每行有2个数字a,b。表示正驾驶员a和副驾驶员b可以同机飞行。注:正驾驶员的编号在前,即正驾驶员的编号小于副驾驶员的编号. OUTPUT输出文件有一行第一行，1个整数，表示最大起飞的飞机数。 SAMPLEINPUT10 51 72 62 103 74 85 9 OUTPUT4 解题报告没啥好说的，第一道网络流= =，以前用二分图水的= =，将正驾驶员与源点连边，副驾驶员与汇点连边，可以搭配的正副驾驶员连边，跑最大流即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int n,n1,n2;struct edge&#123; int s,e,n,w;&#125;a[2001];int pre[101],tot;inline void insert(int s,int e,int w)&#123; a[tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int x,y;int sup;int inf(0x7fffffff);int adj[101];int dis[101];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; if(!a[i].w||dis[a[i].e]) continue; dis[a[i].e]=dis[k]+1; if(a[i].e==t) return true; q.push(a[i].e); &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==sup) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; if(!a[i].w||!tmp||dis[a[i].e]!=dis[now]+1) continue; f=dfs(a[i].e,my_min(a[i].w,tmp)); if(!f)&#123; dis[a[i].e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; return flow-tmp;&#125;inline void dinic(int s,int t)&#123; int ans(0); //bfs(s,t);cout&lt;&lt;"j"; while(bfs(s,t)) ans+=dfs(s,inf); printf("%d",ans);&#125;inline int gg()&#123; freopen("flyer.in","r",stdin); freopen("flyer.out","w",stdout); memset(pre,-1,sizeof(pre)); scanf("%d%d",&amp;n,&amp;n1); sup=n+1; n2=n-n1; while(scanf("%d%d",&amp;x,&amp;y)==2) insert(x,y,1),insert(y,x,0); for(int i=1;i&lt;=n1;i++) insert(0,i,1),insert(i,0,0); for(int i=n1+1,j=1;j&lt;=n2;j++,i++) insert(i,sup,1),insert(sup,i,0); dinic(0,sup);&#125;int K(gg());int main()&#123;;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D6总结]]></title>
    <url>%2F2017%2F07%2F30%2F32%2F</url>
    <content type="text"><![CDATA[考试不是爆零，胜似爆零= =三道题，就拿了20分，根本没法玩好吧= =本来以为打了道正解，打了道暴力，加上个特判分，应该不会死的太惨，然而——为啥我只有特判分啊- -真的是惨。讲完题觉得题是真简单，随便打打感觉都能A，顿感自己的鶸鷄。上解题报告：T1 PasswordT2 [NOIP2015] 斗地主T3 [Lydsy2017年4月月赛]抵制克苏恩自己好弱啊= = 刷题考试的几道题好快的打完了，然而——给予斗地主的帮助比打三道题的时间还长= =，重要的是还有不会打斗地主的同桌= = （hww：喵喵喵？），然后就没有然后了。该复习网络流还得复习网络流 （网络流——从入门到放弃），该刷还得继续刷，就是不知自己还有什么心情了 生活我觉得每天的集训总结都变成了写日记，想写啥的全在不可少的生活篇。其实也没得什么，因为一个U盘差点把自己搞疯，本来用的好好的，结果莫名变成： 您需要Everyone的权限才能进行此操作 我连个Everyone都不是了么。。。然后就开始搞事情，结果某司机手一滑，强行格式化了我的U盘 （内心几近崩溃），然后去找WXH大佬强撸了两个小时，终于恢复了U盘，然而——还是没有权限 （喵喵喵？） 。。。终于放弃了的我，选择写博客，正要往git上push的时候，命令行炸了喵喵喵？然后在某司机的点醒下，我发现我的Node.js没了，它竟然在我的U盘上= =，又强行找WXH要了Node.js，终于push了上去。。。心累啊= = 歌歌歌孤独的人爱酒，漂泊的人喜歌《花火》——汪峰 这是一场没有结局的表演包含所有荒谬和疯狂像个孩子一样满含悲伤静悄悄地熟睡在大地上 现在我有些倦了倦得像一只挣脱了方向 的野鸽所以我开始变了变得像一团暴烈炽热 的花火 看着眼前欢笑 骄傲的人群心中泛起汹涌的浪花跳着放荡的舞蹈 穿行在旷野感到狂野而破碎的辉煌 现在我有些倦了倦得像一支被风折断 的野花所以我开始变了变得像一团滚动炽热 的花火 我开始倦了我开始变了我开始倦了 蓝色的梦睡在 紫色的小车里漂亮的孩子 迷失在小巷这是一个永恒 美丽的结局没有眼泪 没有哀伤 看着眼前欢笑 骄傲的人群心中泛起汹涌的浪花跳着放荡的舞蹈 穿行在旷野感到狂野而破碎的辉煌 现在我有些倦了倦得像一只挣脱了方向 的野鸽所以我开始变了变得像一团暴烈炽热 的花火现在我有些倦了倦得像一支被风折断 的野花所以我开始变了变得像一团滚动炽热 的花火 为数不多的能背下整首歌词的歌，喜欢，能引起心中的共鸣与声音，还有那心底的某些东西]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Lydsy2017年4月月赛]抵制克苏恩]]></title>
    <url>%2F2017%2F07%2F30%2F31%2F</url>
    <content type="text"><![CDATA[题目小Q同学现在沉迷炉石传说不能自拔。他发现一张名为克苏恩的牌很不公平。 如果你不玩炉石传说，不必担心，小Q同学会告诉你所有相关的细节。炉石传说是这样的一个游戏，每个玩家拥有一个 30 点血量的英雄，并且可以用牌召唤至多 7 个随从帮助玩家攻击对手，其中每个随从也拥有自己的血量和攻击力。小Q同学有很多次游戏失败都是因为对手使用了克苏恩这张牌，所以他想找到一些方法来抵御克苏恩。他去求助职业炉石传说玩家椎名真白，真白告诉他使用奴隶主这张牌就可以啦。如果你不明白我上面在说什么，不必担心，小Q同学会告诉你他想让你做什么。现在小Q同学会给出克苏恩的攻击力是 K ，表示克苏恩会攻击 K 次，每次会从对方场上的英雄和随从中随机选择一个并对其产生 1 点伤害。现在对方有一名克苏恩，你有一些奴隶主作为随从，每名奴隶主的血量是给定的。如果克苏恩攻击了你的一名奴隶主，那么这名奴隶主的血量会减少 1 点，当其血量小于等于 0 时会死亡，如果受到攻击后不死亡，并且你的随从数量没有达到 7 ，这名奴隶主会召唤一个拥有 3 点血量的新奴隶主作为你的随从；如果克苏恩攻击了你的英雄，你的英雄会记录受到 1 点伤害。你应该注意到了，每当克苏恩进行一次攻击，你场上的随从可能发生很大的变化。小Q同学为你假设了克苏恩的攻击力，你场上分别有 1 点、 2 点、 3 点血量的奴隶主数量，你可以计算出你的英雄受到的总伤害的期望值是多少吗？ INPUT输入包含多局游戏。 第一行包含一个整数 T (T&lt;100) ，表示游戏的局数。 每局游戏仅占一行，包含四个非负整数 K, A, B和C，表示克苏恩的攻击力是K，你有A个1点血量的奴隶主，B个2点血量的奴隶主，C个3点血量的奴隶主。 保证K是小于50的正数，A+B+C不超过 7 。 OUTPUT对于每局游戏，输出一个数字表示总伤害的期望值，保留两位小数。 SAMPLEINPUT11 1 1 1 OUTPUT0.25 解题报告这题目真长= =，而且以前我难道玩的是假的炉石么= =考试时打了一个假的一维数组递推，半分没骗到= =，然而发现正解是四维的= =正解：概率DP，克苏恩对英雄造成伤害的概率与仆从的数量有关，我们可以设f[i][j][k][l]表示第i时，仆从一滴血的有j个，两滴血的有k个，三滴血的有l个。那么，f[i][j][k][l]可以转移到的状态有： 攻击英雄：f[i+1][j-1][k][l] 攻击一个血量为1的仆从： f[i+1][j-1][k][l]（因为一滴血的受到攻击就死了，故不会召唤仆从） 攻击一个血量为2的仆从： f[i+1][j+1][k-1][l]（当j+k+l==7时，无法继续召唤仆从）OR f[i+1][j+1][k-1][l+1]（当j+k+l&lt;7时，可以继续召唤仆从） 攻击一个血量为3的仆从： f[i+1][j][k+1][l-1]ORf[i+1][j][k+1][l]（情况同上）最后答案就是∑f[i][j][k][l]/(j+k+l+1)剩下的就是代码实现了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;int T;int k,a,b,c;double f[51][8][8][8];double ans(0);int main()&#123; T=read(); while(T--)&#123; memset(f,0,sizeof(f)); k=read(),a=read(),b=read(),c=read(); f[1][a][b][c]=1; ans=0; for(int i=1;i&lt;k;i++) for(int j=0;j&lt;=7;j++) for(int o=0;o&lt;=7;o++) for(int l=0;l&lt;=7;l++)&#123; f[i+1][j][o][l]+=f[i][j][o][l]*(1.0/(j+o+l+1.0)); f[i+1][j-1][o][l]+=f[i][j][o][l]*(j/(j+o+l+1.0)); if(o)&#123; if(j+o+l==7) f[i+1][j+1][o-1][l]+=f[i][j][o][l]*(o/(j+o+l+1.0)); else f[i+1][j+1][o-1][l+1]+=f[i][j][o][l]*(o/(j+o+l+1.0)); &#125; if(l)&#123; if(j+o+l==7) f[i+1][j][o+1][l-1]+=f[i][j][o][l]*(l/(j+o+l+1.0)); else f[i+1][j][o+1][l]+=f[i][j][o][l]*(l/(j+o+l+1.0)); &#125; &#125; for(int i=1;i&lt;=k;i++) for(int j=0;j&lt;=7;j++) for(int o=0;o&lt;=7;o++) for(int l=0;l&lt;=7;l++) ans+=f[i][j][o][l]*1.0/(double)(j+o+l+1.0); printf("%.2lf\n",ans); &#125;&#125; 为啥我当时就推出了个一维递推= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOIP2015] 斗地主]]></title>
    <url>%2F2017%2F07%2F30%2F30%2F</url>
    <content type="text"><![CDATA[题目传送门 INPUT第一行包含用空格隔开的2个正整数Tn，表示手牌的组数以及每组手牌的张数。接下来T组数据，每组数据n行，每行一个非负整数对aibi表示一张牌，其中ai示牌的数码，bi表示牌的花色，中间用空格隔开。特别的，我们用1来表示数码A，11表示数码J，12表示数码Q，13表示数码K；黑桃、红心、梅花、方片分别用1-4来表示；小王的表示方法为01，大王的表示方法为02。 OUTPUT共T行，每行一个整数，表示打光第i手牌的最少次数。 SAMPLEINPUT11 87 48 49 110 411 15 11 41 1 OUTPUT13 INPUT21 1712 34 32 35 410 23 312 20 11 310 16 212 111 35 212 42 27 2 OUTPUT26 解题报告考试时光顾着T3了，看到它时间根本不够= =，拿了小数据特判分走人= =显然是个暴搜模拟。首先，显然花色没用，大王小王也可以看做一样的牌，而且，出牌顺序显然没有影响。那么剩下的就很简单了，我们先出牌多的（正确性显然，因为这样答案一开始就不会很大，然后你可以用当前答案剪枝，因为已经不比当前答案优的解不可能推出最优解，这样，你可以利用较优的解减掉许多劣解，从而优化），并且，显然顺子一般来说要比带牌要优，那么剩下的就很简单了，注意一些出牌规则，不要像某些不会斗地主的小兄弟 （hww：喵喵喵？） 一样= =要注意的是，顺子不一定越长越好，比如考虑这样一副牌： 3 4 5 6 7 8 9 9 10 10 J J 若是以越长越优的话，你会做出先打出顺子3~J，再单打9、10、J的决定，但显然打3~8的顺子加9~J的连对更优一些，所以我们在枚举顺子时，需要枚举所有可能的长度。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;int size[30];int n,ans;inline int get_val(int x)&#123; if(x==1) return 12; if(x==2) return 13; if(x==0) return 14; return x-2;&#125;inline int doit()&#123; int tmp(0); int tp[6]=&#123;0&#125;; for(int i=1;i&lt;=14;i++) tp[size[i]]++; while(tp[4]&amp;&amp;tp[2]&gt;=2) tmp++,tp[4]--,tp[2]-=2;//四带俩对 while(tp[4]&amp;&amp;tp[1]&gt;=2) tmp++,tp[4]--,tp[1]-=2;//四带俩单 while(tp[3]&amp;&amp;tp[2]&gt;=1) tmp++,tp[3]--,tp[2]--;//三带二 while(tp[3]&amp;&amp;tp[1]&gt;=1) tmp++,tp[3]--,tp[1]--;//三带一 tmp+=tp[1]+tp[2]+tp[3]+tp[4]; return tmp;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void dfs(int cnt)&#123; if(cnt&gt;ans) return; int x(doit()); ans=my_min(ans,cnt+x); for(int i=1;i&lt;=11;i++)&#123;//三顺子 int j; for(j=i;size[j]&gt;=3&amp;&amp;j&lt;=12;j++); if(j-i&lt;2) continue; for(int k=j;k-i&gt;=2;k--)&#123; for(int l=i;l&lt;k;l++) size[l]-=3; dfs(cnt+1); for(int l=i;l&lt;k;l++) size[l]+=3; &#125; &#125; for(int i=1;i&lt;=10;i++)&#123;//连对 int j; for(j=i;size[j]&gt;=2&amp;&amp;j&lt;=12;j++); if(j-i&lt;3) continue; for(int k=j;k-i&gt;=3;k--)&#123; for(int l=i;l&lt;k;l++) size[l]-=2; dfs(cnt+1); for(int l=i;l&lt;k;l++) size[l]+=2; &#125; &#125; for(int i=1;i&lt;=8;i++)&#123;//顺子 int j; for(j=i;size[j]&gt;=1&amp;&amp;j&lt;=12;j++); if(j-i&lt;5) continue; for(int k=j;k-i&gt;=5;k--)&#123; for(int l=i;l&lt;k;l++) size[l]--; dfs(cnt+1); for(int l=i;l&lt;k;l++) size[l]++; &#125; &#125;&#125;inline int gg()&#123;// freopen("landlords.in","r",stdin);// freopen("landlords.out","w",stdout); int T(read()); n=read(); while(T--)&#123; memset(size,0,sizeof(size)); for(int i=1;i&lt;=n;i++)&#123; int x(read()),y(read()); size[get_val(x)]++; &#125; ans=doit(); dfs(0); printf("%d\n",ans); &#125; return 0;&#125;int K(gg());int main()&#123;;&#125; 这一顿暴搜= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Password]]></title>
    <url>%2F2017%2F07%2F30%2F29%2F</url>
    <content type="text"><![CDATA[题目 Rivest是密码学专家。近日他正在研究一种数列E = {E[1],E[2],……,E[n]}，且E[1] = E[2] = p（p为一个质数），E[i] = E[i-2]×E[i-1] （若2&lt;i&lt;=n）。 例如{2,2,4,8,32,256,8192,……}就是p = 2的数列。在此基础上他又设计了一种加密算法，该算法可以通过一个密钥q (q &lt; p)将一个正整数n加密成另外一个正整数d，计算公式为：d = E[n] mod q。现在Rivest想对一组数据进行加密，但他对程序设计不太感兴趣，请你帮助他设计一个数据加密程序。 INPUT第一行读入m，p。其中m表示数据个数，p用来生成数列E。 以下有m行，每行有2个整数n，q。n为待加密数据，q为密钥。 数据范围: 0 &lt; p n&lt; 2^31 0 &lt; q &lt; p 0 &lt; m &lt;= 5000。 OUTPUT将加密后的数据按顺序输出到文件 第i行输出第i个加密后的数据。 SAMPLEINPUT12 74 54 6 OUTPUT131 INPUT24 72 47 16 59 3 OUTPUT23011 解题报告考试时候本以为推了个正解，又强行推出了实现，结果= =还不如打个暴力正解：首先写个公式： a^b%p=a^(b%phi(p))%p 其中，phi(p)为p的欧拉函数。不要问我怎么证，我不会然后，我们可以得出，要求的显然就是p^fib(i)%q,其中fib(i)为斐波那契数列的第i项。显然，正经递推斐波那契是会T的。所以我们考虑优化，显然可以用矩阵快速幂解决问题。那么，剩下的就很简单了。直接快速幂就可以解决了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long L;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;L m,p,n,q;L fib;L unit[2][2],start[2][2];inline void multi(L a[][2],L b[][2],L mod)&#123; L tmp[2][2]=&#123;0&#125;; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) tmp[i][j]=(tmp[i][j]+a[i][k]*b[k][j])%mod; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) b[i][j]=tmp[i][j];&#125;inline int get_phi(L x)&#123; L ret(x); for(int i=2;i*i&lt;=x;i++) if(x%i==0)&#123; ret=ret-ret/i; while(x%i==0) x/=i; &#125; if(x&gt;1) ret=ret-ret/x; return ret;&#125;inline L fi(L p,L mod)&#123;/* if(p==0) return 0; if(p==1||p==2) return 1;*/ start[0][0]=start[1][0]=start[0][1]=1,start[1][1]=0; unit[0][0]=unit[1][1]=1,unit[1][0]=unit[0][1]=0; while(p)&#123; if(p&amp;1) multi(start,unit,mod); multi(start,start,mod); p&gt;&gt;=1; &#125; return unit[0][1];&#125;L mod;inline L qpow(L a,L p,L mod)&#123; L ret(1); while(p)&#123; if(p&amp;1) ret*=a,ret%=mod; a*=a,a%=mod; p&gt;&gt;=1; &#125; return ret;&#125;int main()&#123;// freopen("1.in","r",stdin);// freopen("1.out","w",stdout); m=read(),p=read(); while(m--)&#123; n=read(),q=read(); mod=get_phi(q); fib=fi(n,mod); fib%=mod; printf("%lld\n",qpow(p,fib,q)%q); &#125;&#125; 突然莫名觉得这题没啥好写的，好水啊2333，然而还是爆零了]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D5总结]]></title>
    <url>%2F2017%2F07%2F29%2F28%2F</url>
    <content type="text"><![CDATA[%dalao今天又有dalao来讲课，讲的是网络流网络流——从入门到放弃：7-29dalao讲课笔记果然是从入门到放弃啊，dalao本来说好下午继续讲完的，然后——就没有然后了重要的是，mdzz PPT上的板子是假的啊，我找了一下午正经的板子啊，本以为ljm给了个正经板子，没想到是个假的啊，好不容易准备用stdafx的权限号交一下权限题，结果： stdafx, 很抱歉的通知您，您今天的提交次数已经达到了日上限50次，请明日再来提交。 满腔怒火无处发泄啊 刷题就像刚才说的，我打了一下午的板子，结果发现，板子是假的啊啊啊，我的邻接表把我卡了啊啊啊然后，我就十分愤怒而又绝望地什么事都不想干了= =据说做网络流的题不用算复杂度，都是O(能过) 生活今天早上雨下得好大，然而刚好赶着我们起床去机房的时间，上午就变成了大晴天- -，对于我这种来说- -，真是 （亦可赛艇.jpg）然而又是照例让两人 （这就不说名字了啊喂） 帮我买饭 （好像今天渊渊没有买饭） = =，然而晚饭终于吃了这几天来唯一一顿正常的饭= =（帮你买饭哪来这么多事啊喂）倒腾一大圈的博客，终于 （把博客搞烂了） 成功的换了博客主题，还顺便学习了一下mathjax的用法 （不但没学会，还删了不知道什么东西），最后终于学会了语法 （因为根本没有在实践中成功），嗯，好充实的一天啊 （充实个鬼，乱搞了一圈还不如颓）现在是真的不知道干什么了- -，刷不动题，写不动题解，只能默默的乱搞，还要装作很充实的样子，实际上每天起床就在盼着夜晚的来临，然后盼着假期回家，最后十分不情愿的回到高考课，我。。。 心累啊。 想当初我在博客上是怎么写的？ 总之就是这样了，赶紧放假，等着下次集训呢 但，当几乎没有的暑假已经过去，盼望的集训到来，我现在又是什么心情呢。我不知道我是怎么想的，事实上可能也不会有谁知道了吧。 继续唱歌？《Beautiful》——Eminem Lately I’ve been hard to reach.I’ve too long on my own.Everybody has a private world where they can be alone.Are you calling me?Are you trying to get through?Are you reaching out for me?I’m gonna reaching out for you. Walk in my shoesJust to seeWhat is likeTo be meI’ll be youLet trade shoesJust to see that would we like toFeel your painYou feel mineGo inside to each other’s lifeJust to seeWhat we would findLook at shit in each other’s eyeBut don’t let them say you ain’t beautiful ooohThey can all get fucked,just stay true to you soohBut don’t let them say you ain’t beautiful ooohThey can all get fucked,just stay true to you sooh 一首歌，一种心情]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-7-29 大佬讲课笔记]]></title>
    <url>%2F2017%2F07%2F29%2F27%2F</url>
    <content type="text"><![CDATA[网络流虽然dalao声音不大，但是很好听呢。不过dalao很快的进入正经主题了呢。 基本定义 有n个点，m条有向边，其中源点 s 只有出边，没有入边。汇点 t 只有入边，没有出边。 每条边都有一个容量和流量，通常用c(u,v)表示从u到v的容量，f(u,v)代表流量。 我们可以把这些有向边想象成运输管道，有一定数量的物品，从源点 s 出发，经过这些管道，最终流入汇点t，而每条管道的运输单个物品的次数是有限的。 可行流 源点s的总流出量等于汇点t的总流入量 其它点的总流入量等于总流出量 每条边的流量不超过容量上限 增广路基本概念 假设有这样一条路径，从源点s一直到汇点t每条边的已用流量都小于容量，那我们便能找到在这条路径上能够增加的流量的最大值 val = min{c(u,v)-f(u,v)}。加上这个值后，这个流依然是可行流，而这条路径就是增广路。 残余网络：每条边减去已用的流量，再在反向边上加上相同的流量。 思路从零流开始不断寻找增广路 依据 增广路定理：假如当前残余网络中仍能找到一条增广路，那么当前的可行流仍可以增大，不是最大流。反之，如果到了“无路可增”的地步，当前流就是最大流。 实现过程 为什么要加反向边？首先，假如没有反向边的话，那么找增广路其实是需要按照一定的组合，才能找到最大流。也就是说，我们无法在找到一条增广路时，确保这样可能是一种可行的最大流的方案。因此，我们需要对前面的方案进行调整，比如有的边流量不需要使用，需要“退”回去，反向边就起到这样的作用。 在实际运行过程中反向边与原来的边是没有区分的，这样一步步找增广路就可以确保最终为最大流。 EdmondsKarp不断bfs，每一次遍历O(n²)，最多遍历m次，O(m*n²)的复杂度123456789101112131415161718192021222324252627282930313233343536int bfs() &#123; memset(pre,-1,sizeof(pre)); for(int i=1;i&lt;=n;++i) flow[i]=INF; queue&lt;int&gt;q; pre[S]=0,q.push(S); while(!q.empty())&#123; int op(q.front()); q.pop(); for(int i=1;i&lt;=n;++i)&#123; if(i==S||pre[i]!=-1||c[op][i]==0) continue; pre[i]=op; //找到未遍历过的点 flow[i]=min(flow[op],c[op][i]); // 更行路径上的最小值 q.push(i); &#125; &#125; if(flow[T]==INF) return -1; return flow[T];&#125;int solve() &#123; int ans(0); while(1)&#123; int k(bfs()); if(k==-1) break; ans+=k; int nw(T); while(nw!=S)&#123;//更新残余网络 c[pre[nw]][nw]-=k,c[nw][pre[nw]]+=k; nw=pre[nw]; &#125; &#125; return ans;&#125; Dinic bfs建立层次图 在层次图中dfs直到找不到增广路 重复以上过程直到找不到增广路每次重新分层，汇点所在层次严格递增。n个点的层次图最多n层，所以最多重新分层n次。在同一个层次图中，每条增广路都有一个瓶颈，即最小值的限制所在边，而两次增广的瓶颈不可能相同，所以增广路最多m条。搜索每一条增广路时，前进和回溯都最多n次（最多n个点），所以一次dfs是O(nm)的复杂度。综上，是O(m*n²)的复杂度。123456789101112131415161718192021222324252627282930313233343536bool bfs()&#123;//bfs建立层次图 memset(dep,0,sizeof(dep)); hd=tl=0; q[++tl]=s; dep[s]=1; while(hd&lt;tl)&#123; int op(q[++hd]); for(int i=headlist[op];i!=-1;i=edge[i].next)&#123; if(edge[i].val&amp;&amp;(!dep[edge[i].v]))&#123; dep[edge[i].v]=dep[op]+1; q[++tl]=edge[i].v; if(edge[i].v==t)//遍历到t就返回，此时该层次图已建好 return true;//再访问其它的点没有必要 &#125; &#125; &#125; return false;&#125;int dfs(int op,int fw)&#123; if(op==t) return fw; int tmp(fw),k; for(int i=headlist[op];i!=-1;i=edge[i].next)&#123; if(edge[i].val&amp;&amp;tmp&amp;&amp;dep[edge[i].v]==dep[op]+1)&#123; k=dfs(edge[i].v,min(edge[i].val,tmp)); if(!k)&#123;//该点后面没有路径，所以要从层次图中删去 dep[edge[i].v]=0;//因为和当前点op层次相同的点 continue;//还可能会访问到它 &#125; edge[i].val-=k; edge[i^1].val+=k; tmp=k; &#125; &#125; return fw-tmp;&#125; 最大流 网络流中大部分可以分为两种类型的点：与S相连的点和与T相连的点。所以建模的时候也可以向这方面考虑，将点分成两个集合。 搭配飞行员传送门题目大意：有n(n ≤ 100)个驾驶员（其中包括a个正驾驶员和b个副驾驶员）驾驶一种飞机，每架需要一个正驾驶员和一个副驾驶员。有些驾驶员不能在同一架飞机上，问如何搭配驾驶员才能使出航的飞机最多。题解：题意很明了，将正驾驶员与S相连，容量为1，将副驾驶员与T相连，边容量为1，将可以在一辆飞机上的正驾驶员和副驾驶员相连，边容量&gt;0即可。与S，T相连的边限制了驾驶员的搭配次数，中间的边就无需再限制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;int n,n1,n2;struct edge&#123; int s,e,n,w;&#125;a[2001];int pre[101],tot;inline void insert(int s,int e,int w)&#123; a[tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int x,y;int sup;int inf(0x7fffffff);int adj[101];int dis[101];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; if(!a[i].w||dis[a[i].e]) continue; dis[a[i].e]=dis[k]+1; if(a[i].e==t) return true; q.push(a[i].e); &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==sup) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; if(!a[i].w||!tmp||dis[a[i].e]!=dis[now]+1) continue; f=dfs(a[i].e,my_min(a[i].w,tmp)); if(!f)&#123; dis[a[i].e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; return flow-tmp;&#125;inline void dinic(int s,int t)&#123; int ans(0); //bfs(s,t);cout&lt;&lt;"j"; while(bfs(s,t)) ans+=dfs(s,inf); printf("%d",ans);&#125;inline int gg()&#123; freopen("flyer.in","r",stdin); freopen("flyer.out","w",stdout); memset(pre,-1,sizeof(pre)); scanf("%d%d",&amp;n,&amp;n1); sup=n+1; n2=n-n1; while(scanf("%d%d",&amp;x,&amp;y)==2) insert(x,y,1),insert(y,x,0); for(int i=1;i&lt;=n1;i++) insert(0,i,1),insert(i,0,0); for(int i=n1+1,j=1;j&lt;=n2;j++,i++) insert(i,sup,1),insert(sup,i,0); dinic(0,sup);&#125;int K(gg());int main()&#123;;&#125; 士兵占领传送门题面：有一个n*m的棋盘，有的格子是障碍。现在你要选择一些格子来放置一些士兵，一个格子里最多可以放置一个士兵，障碍格里不能放置士兵。要求第i行至少放置了ri个士兵，第j列至少放置了cj个士兵。求士兵最少是多少。假设我们不考虑一个位置对它所在行，列两者的贡献。那么答案就是sum=∑(i 1~n)ri+∑(j 1~m)cj。但实际上，有的点对两者都有贡献，结果为sum减去的点的数量，士兵数量最少即这样的点数量最多。之后，建图和上一道题类似。将每行作为一个点与S相连，容量为ri，每列作为一个点与T相连，容量为cj。可以放士兵的点行与列相连，容量为1.跑最大流就可以求出上述点的最大值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+ch-'0',ch=getchar()); return sum;&#125;struct edge&#123; int s,e,w,n;&#125;a[50001];int pre[250],tot;inline void insert(int s,int e,int w)&#123; a[tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m,k;int sup;int l[101],c[101];bool g[101][101];int sum(0);int dis[301];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); queue&lt;int&gt;q; q.push(s); dis[s]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; if(!a[i].w||dis[a[i].e]) continue; dis[a[i].e]=dis[k]+1; if(a[i].e==t) return true; q.push(a[i].e); &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==sup) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; if(!a[i].w||!tmp||dis[a[i].e]!=dis[now]+1) continue; f=dfs(a[i].e,my_min(a[i].w,tmp)); if(!f)&#123; dis[a[i].e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; return flow-tmp;&#125;inline bool judge()&#123; int tmp; for(int i=1;i&lt;=m;i++)&#123; tmp=0; for(int j=1;j&lt;=n;j++) if(g[i][j]) tmp++; if(tmp&lt;l[i]) return true; &#125; for(int j=1;j&lt;=n;j++)&#123; tmp=0; for(int i=1;i&lt;=m;i++) if(g[i][j]) tmp++; if(tmp&lt;c[j]) return true; &#125; return false;&#125;int ans(0),inf(0x7fffffff);int main()&#123; memset(pre,-1,sizeof(pre)); memset(g,true,sizeof(g)); m=read(),n=read(),k=read(); sup=n+m+1; for(int i=1;i&lt;=m;i++) l[i]=read(),sum+=l[i]; for(int i=1;i&lt;=n;i++) c[i]=read(),sum+=c[i]; for(int i=1;i&lt;=k;i++)&#123; int x(read()),y(read()); g[x][y]=0; &#125; if(judge())&#123; puts("JIONG!"); return 0; &#125; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=n;j++) if(g[i][j]) insert(i,j+m,1),insert(j+m,i,0); for(int i=1;i&lt;=m;i++) insert(0,i,l[i]),insert(i,0,0); for(int i=1;i&lt;=n;i++) insert(i+m,sup,c[i]),insert(sup,i+m,0); while(bfs(0,sup)) ans+=dfs(0,inf); printf("%d",sum-ans); return 0;&#125; 分子切割题目描述：有一个由n*m个单位放个组成的矩形区域。有两种原子，用A和B表示。有的单位方格中没有原子，有的单位方格中只有一个原子。若两个单位方格有公共边，那么他们是相邻的。如果一个A原子与两个B原子相邻，并且这两个B原子与A原子形成直角，A原子在直角的定点处，那么就可以把这三个原子整体切割下来，得到一个“L”形分子。求最多切割出多少个“L”形分子。（n，m ≤ 500）题解：要黑白染色我们可以想到肯定是由S-B-A-B-T这样一条路径代表一个“L”形分子。之后便是建模限制每个点的使用次数以及B-A-B是直角。由此可以看出如果所有的B是一类点肯定是行不通的。但我们注意到一个“L”形分子的两个B原子必在相邻的两列（行）上，就可以按列（行）染色了。S向奇数列的B点建边容量为1，奇数列的B点只能流向周围的A点。偶数列的B点向T建边容量为1，且只能由周围的A点流向偶数列的B点这样就可以保证流过的B-A-B一定是直角。但这样并不能保证A的使用次数，如上图所示，A会重复使用。为了限制A的使用次数，我们可以拆点，将A拆成两个点A1和A2，同时在A1A2间连一条容量为1的边，流入A的连A1，流出A的连A2。 紧急疏散传送门题解：显然肯定有一个时间，在此之前不能完全逃离，在此之后可以完全逃离。这样我们就可以二分了。每个位置上人数不限，所以除去到门上时，每个人可以单独考虑。对一扇门来说，每个人到门前的时间可能不同，即每个人可以利用门逃离的时间段不同，我们要限制每个人可使用的时间，可以每扇门每个时间单独一个点。 具体建模：S向每个人连边，容量为1。每个人向每扇门可以使用的时间的一系列点连边，容量为1，每扇门的每个时间点向T连边，容量为1。每个人每扇门可以使用的时间即这个人到这扇门最短时间及以后，所以要先跑一遍最短路。这样，当最大流等于人的数量时，就可以完全逃离。 Collector’s Problem题目描述：Bob和他的朋友从糖果包装里收集贴纸。Bob和他的朋友总共n人。共有m种不同的贴纸。每人手里都有一些（可能有重复的）贴纸，并且只跟别人交换他所没有的贴纸。贴纸总是一对一交换。Bob比这些朋友更聪明，因为他意识到只跟别人交换自己没有的贴纸并不总是最优的。在某些情况下，换来一张重复的贴纸更划算。假设Bob的朋友只跟Bob交换（他们之间不交换），并且这些朋友只会出让手里的重复贴纸来交换他们没有的不同贴纸。你的任务是帮助Bob算出他最终可以得到的不同贴纸的最大数量。2≤n≤10,5≤m≤25题解：对于Bob的每个朋友，Bob最多只能与他交换x次（这个朋友没有的贴纸的种数与他拥有的重复贴纸数量的较小值）。Bob朋友的作用就是将Bob手中的一种贴纸X换成另一种贴纸Y。所以将每种贴纸作为一个结点，由S向其连边，容量为Bob拥有的没中贴纸的数量，并且向T连边，容量为1。对于每个朋友，其没有的贴纸的点向其连边，容量为1（最多换一次）。并且他向拥有的重复贴纸的点连边，容量为num-1。 这样从一种贴纸的结点流经一个朋友再流向另一种贴纸，就等于完成了一次交换，而由于又流回了贴纸结点仍然可以用该贴只去做交换。 这样最大流便是能够拥有的贴纸的最大种数。 最小割定义 把所有的结点分为两个集合S和T，其中s在S中，t在T中。把所有起点在S中，终点在T中的边删除，就无法从s到达t了，这样的一个划分称为s-t割，它的容量为删除的所有边的容量的总值，最小割即为所有s-t割中的最小值。 求解最小割基于一个事实：最小割等于最大流证明：对于一个割来说，所有从s到t的流量必定经过删除的边，那么最大流一定&lt;=割的值，同理可以推出最大流&lt;=任意割的值。下面来看一个已经跑完最大流的残余网络，此时图中已没有从s到t的路径。将s和s能到达的所有点划分为S集，剩余点为T集。中间的所有边为一个割，且均满载（剩余容量为0），那么当前流也就是最大流等于割的值，又因割的值大于等于最大流，所以此时的割即为最小割，且与最大流相等。 王者之剑传送门取值时一定在偶数时刻，取走一个格子的值后，就不能取走与其相邻格子的值，也就是相邻格子之间是不相容的。证明：假设取值时在奇数时刻，那么取值前的上一个时刻，必定在这个格子的相邻格子中，而那时又是偶数时刻，所以这个格子的值会消失，无法取到。 题解：这道题可以从怎样走的思维模式中跳出来，转化到怎样去取上。因为只要取的格子相容，是一定有合法路径的。有不容的点就可以转化到最小割上，用总值减去割掉最小的值，就是最优解。 具体建模：此时是若两者都取不相容，所以需要翻转源汇。将矩阵按黑白棋盘染色，S与白点相连，容量为权值，黑点与T相连，容量为权值。不相容的点之间连边，容量为INF。S对于白点来说为取，T对于黑点来说为取。从一条路径来看，S-白-黑-T，因为中间的边为极大值，所以只能割两边的边，割掉的边即为不取的值。求出最小割即为能使剩余点相容的减去的最小总值。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[2000001];int pre[100001],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m;int w[105][105],col[105][105];inline void paint()&#123; int now(1); for(int i=1;i&lt;=n;i++)&#123; now^=1; for(int j=1;j&lt;=m;j++)&#123; if(j&amp;1) col[i][j]=now; else col[i][j]=now^1; &#125; &#125;&#125;int S(0),T;int ans(0),inf(0x7fffffff),sum(0);inline void build()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(col[i][j]) insert(S,(i-1)*m+j,w[i][j]),insert((i-1)*m+j,S,0); else insert((i-1)*m+j,T,w[i][j]),insert(T,(i-1)*m+j,0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(col[i][j])&#123; if(i!=1) insert((i-2)*m+j,(i-1)*m+j,0),insert((i-1)*m+j,(i-2)*m+j,inf); if(i!=n) insert(i*m+j,(i-1)*m+j,0),insert((i-1)*m+j,i*m+j,inf); if(j!=1) insert((i-1)*m+j-1,(i-1)*m+j,0),insert((i-1)*m+j,(i-1)*m+j-1,inf); if(j!=m) insert((i-1)*m+j+1,(i-1)*m+j,0),insert((i-1)*m+j,(i-1)*m+j+1,inf); &#125; &#125;&#125;int dis[10010];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125; inline int gg()&#123; freopen("Excalibur.in","r",stdin); freopen("Excalibur.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); T=n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read(),sum+=w[i][j]; paint(); build(); while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",sum-ans); return 0;&#125;int K(gg());int main()&#123;;&#125; happiness传送门题解：此题与上一题相似，不过这次是选择不同时不能得到额外的权值，无需翻转源汇，S对所有点来说都是文科，T对所有点来说都是理科。对于单独两个点来说，只有两种情况。若两个人都选文科，需要割掉第2，4条边，代价为两个人选理科分别的贡献，以及他们一起选理科的贡献，因为所有的点都是等价的，2，4边的权值除各自选理科贡献外再加上一半的额外贡献。若两个人都选择理科同理。 若两个人选择不同，假设x选择文科，y选择理科，那么需要割掉2，3，5。此时2，3权值和为分别选择科目的贡献和一半的同时选择理科和同时选择文科的贡献。还需再减去剩余的一半，即应是5的权值。(x，y间要建双向边。)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[200001];int pre[10010],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int n,m;int w[101][101],l[101][101];int jz1[101][101],jz2[101][101],jz3[101][101],jz4[101][101];int sum(0),ans(0),inf(0x7fffffff);int S(0),T;int id[101][101];inline void init()&#123; freopen("nt2011_happiness.in","r",stdin); freopen("nt2011_happiness.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); T=n*m+1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) w[i][j]=read()&lt;&lt;1,sum+=w[i][j]&gt;&gt;1,id[i][j]=(i-1)*m+j; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) l[i][j]=read()&lt;&lt;1,sum+=l[i][j]&gt;&gt;1; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) jz1[i][j]=read(),sum+=jz1[i][j]; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) jz2[i][j]=read(),sum+=jz2[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++) jz3[i][j]=read(),sum+=jz3[i][j]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++) jz4[i][j]=read(),sum+=jz4[i][j];&#125;inline void build()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; insert(S,id[i][j],w[i][j]+jz1[i][j]+jz1[i-1][j]+jz3[i][j]+jz3[i][j-1]),insert(id[i][j],S,0); insert(id[i][j],T,l[i][j]+jz2[i][j]+jz2[i-1][j]+jz4[i][j]+jz4[i][j-1]),insert(T,id[i][j],0); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(i!=n) insert(id[i][j],id[i][j]+m,jz1[i][j]+jz2[i][j]),insert(id[i][j]+m,id[i][j],jz1[i][j]+jz2[i][j]); if(j!=m) insert(id[i][j],id[i][j]+1,jz3[i][j]+jz4[i][j]),insert(id[i][j]+1,id[i][j],jz3[i][j]+jz4[i][j]); &#125;&#125;int dis[10020];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125;inline void dinic()&#123; while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",sum-(ans&gt;&gt;1));&#125;inline int gg()&#123; init(); build(); dinic(); return 0;&#125;int K(gg());int main()&#123;;&#125; 人员雇佣传送门题解：这道题与上一道考虑角度相同，首先从两个人的角度考虑若两个人都被雇佣，割掉的边为2，4，权值分别为雇佣二人的代价。若两个人都不被雇佣，需要割掉1，3，权值均为两人共同的收益。因为共同收益，两人是两份。若两人选择不同，假设x被雇佣，y不被雇佣，需要割掉2，3，5。而此时还应减去一份存在于1中的共同受益，再减去两人选择不同的减损。也就是要减去两份共同收益，即为5的权值。 切糕传送门题解：由题意得知，显然为最小割模型，将点权转化为边权。由S向(x,y,1)连边，边权为v(x, y,1)。由(x, y, z)向(x, y, z+1)连边，边权为v(x, y, z+1)。最后由(x, y, R)向T连边，边权为INF。此题关键为这个选择的距离限制。我们可以这样解决：由每个点向它相邻的点的下方的第d个点连边。也就由(x, y, z)向(x, y, z-d)连边，边权为INF。首先，假设每条纵轴只割一条边。若两条边的距离大于d，一定会有图中所示路径，此时仍需要再割一条边。假设再割一条右侧的边，此边与左边割掉的那条边的距离要 ≤ d，否则还会出现这样的路径。只有距离 ≤ d，才能截断。但此时，右边第一次截断的边已经没有必要了。因为只要上面两条边就可以截断了。因此，每个纵轴只截断一条边，且相邻截断的边距离一定 ≤ d。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int e,n,w;&#125;a[1000001];int pre[64500],tot;inline void insert(int s,int e,int w)&#123; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot++;&#125;int p,q,r,d;int id[41][41][41],w[41][41][41];int cnt(0);int S(0),T;int ans(0),inf(0x7fffffff);int dis[64500];inline bool bfs(int s,int t)&#123; memset(dis,0,sizeof(dis)); dis[s]=1; queue&lt;int&gt;q; q.push(s); while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dis[e]&amp;&amp;a[i].w)&#123; dis[e]=dis[k]+1; q.push(e); if(e==t) return true; &#125; &#125; &#125; return false;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int dfs(int now,int flow)&#123; if(now==T) return flow; int tmp(flow),f; for(int i=pre[now];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(dis[e]==dis[now]+1&amp;&amp;tmp&amp;&amp;a[i].w)&#123; f=dfs(e,my_min(tmp,a[i].w)); if(!f)&#123; dis[e]=0; continue; &#125; a[i].w-=f; a[i^1].w+=f; tmp-=f; &#125; &#125; return flow-tmp;&#125;inline int gg()&#123; freopen("nutcake.in","r",stdin); freopen("nutcake.out","w",stdout); memset(pre,-1,sizeof(pre)); p=read(),q=read(),r=read(),d=read(); T=p*q*r+1; for(int i=1;i&lt;=r;i++) for(int j=1;j&lt;=p;j++) for(int k=1;k&lt;=q;k++)&#123; w[i][j][k]=read(); id[i][j][k]=++cnt; insert(id[i-1][j][k],id[i][j][k],w[i][j][k]),insert(id[i][j][k],id[i-1][j][k],0); if(i==r) insert(id[i][j][k],T,inf),insert(T,id[i][j][k],0); if(i&gt;d)&#123; if(j!=1) insert(id[i][j][k],id[i-d][j-1][k],inf),insert(id[i-d][j-1][k],id[i][j][k],0); if(j!=p) insert(id[i][j][k],id[i-d][j+1][k],inf),insert(id[i-d][j+1][k],id[i][j][k],0); if(k!=1) insert(id[i][j][k],id[i-d][j][k-1],inf),insert(id[i-d][j][k-1],id[i][j][k],0); if(k!=q) insert(id[i][j][k],id[i-d][j][k+1],inf),insert(id[i-d][j][k+1],id[i][j][k],0); &#125; &#125; while(bfs(S,T)) ans+=dfs(S,inf); printf("%d",ans); return 0;&#125;int K(gg());int main()&#123;;&#125; 费用流最小费用最大流在保证最大流的基础上，使总费用最小这类问题中每条边除了容量还有花费，建边时圆边为原本花费，反向边为花费的负数。每条边的花费为使用流量乘以单位流量的花费,所有边的花费就是总花费。通过前面的最大流定理，我们知道只要不断地寻找增广路，就可以找到最大流。那么为了最小费用，我们只需在找增广路时，贪心找到单位流量费用最小的那条增广路即可。证明： 每次寻找的增广路的单位最小费用一定是不下降的。 寻找增广路的过程中不会出现负环。 局部最优一定是整体最优 123456789101112131415161718192021222324252627282930313233bool FIND(int st,int ed,int &amp;fw,int &amp;Cost)&#123; memset(dis,0x3f,sizeof(dis)); memset(ins,false,sizeof(ins)); memset(pr,0,sizeof(pr)); inf = dis[0]; queue &lt;int&gt; q; q.push(st), dis[st] = 0, a[st] = inf; while(!q.empty()) &#123; int op = q.front(); q.pop(); ins[q] = false; for(int i = headlist[q] ; i != -1 ; i = Edge[i].next) &#123; if(Edge[i].val&amp;&amp;dis[Edge[i].v]&gt;dis[op]+Edge[i].cost) &#123; dis[sg[i].v] = dis[op]+Edge[i].cost; pr[Edge[i].v] = i; a[Edge[i].v] = MIN(a[op],Edge[i].val); if(!ins[Edge[i].v]) &#123; ins[Edge[i].v] = true; q.push(Edge[i].v); &#125; &#125; &#125; &#125; if(dis[ed]==inf) return false; fw += a[ed]; Cost += dis[ed]*a[ed]; int w = ed; while(w!=st) &#123; Edge[pr[w]].val -= a[ed]; Edge[pr[w]^1].val += a[ed]; w = Edge[pr[w]].u; &#125; return true;&#125; 餐巾传送门题解：首先，每天的餐巾分为两种情况，新买的和原来的。每天作为一个点，由S向其连边，容量为Ri，花费为0。每天可以向T连边，容量为INF，花费为p，每天都可以购买餐巾无数次。将每天用过的餐巾在新建一层点，由于分配去快洗和慢洗的餐巾总数有限制，并非分别有限制，所有这两种无需再分开，这层点分别向T建边，容量为Ri，花费为0，限制总容量。使用快洗的餐巾，由i向(i+m+N)’建边，容量为INF，花费为f，慢洗同理，花费分别建边。但第i-m天洗完后的餐巾也可以供第i天以后使用。所以再由i向i+1建边，容量为INF，花费为0。这样第i天就能使用到以前所有可以使用的洗完的餐巾了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;struct edge&#123; int e,n,flow,cost;&#125;a[20010];int pre[410],tot;inline void insert(int s,int e,int flow,int cost)&#123; a[tot].e=e; a[tot].flow=flow; a[tot].cost=cost; a[tot].n=pre[s]; pre[s]=tot++;&#125;int S(0),T;int N,p,m,f,n,s;int r[201];int flow(0),ans(0),inf(0x7fffffff);inline void build()&#123; for(int i=1;i&lt;=N;i++)&#123; insert(S,i,r[i],0),insert(i,S,0,0); insert(S,i+N,inf,p),insert(i+N,S,0,-p); insert(i+N,T,r[i],0),insert(T,i+N,0,0); if(i+m&lt;=N) insert(i,i+m+N,inf,f),insert(i+m+N,i,0,-f); if(i+n&lt;=N) insert(i,i+n+N,inf,s),insert(i+n+N,i,0,-s); if(i!=N) insert(i,i+1,inf,0),insert(i+1,i,0,0); &#125;&#125;int dis[410],fa[410],path[410];inline bool bfs()&#123; memset(dis,30,sizeof(dis)); memset(fa,-1,sizeof(fa)); queue&lt;int&gt;q; q.push(S); dis[S]=0; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=pre[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(a[i].flow&amp;&amp;dis[e]&gt;dis[k]+a[i].cost)&#123; dis[e]=dis[k]+a[i].cost; fa[e]=k; path[e]=i; q.push(e); &#125; &#125; &#125; if(fa[T]==-1) return false; return true;&#125;inline void dinic()&#123; while(bfs())&#123; int f(inf); for(int i=T;i!=S;i=fa[i]) if(a[path[i]].flow&lt;f) f=a[path[i]].flow; flow+=f; ans+=dis[T]*f; for(int i=T;i!=S;i=fa[i])&#123; a[path[i]].flow-=f; a[path[i]^1].flow+=f; &#125; &#125;&#125;inline int gg()&#123; freopen("napkin.in","r",stdin); freopen("napkin.out","w",stdout); memset(pre,-1,sizeof(pre)); scanf("%d",&amp;N); T=(N&lt;&lt;1)+1; for(int i=1;i&lt;=N;i++) scanf("%d",&amp;r[i]); scanf("%d%d%d%d%d",&amp;p,&amp;m,&amp;f,&amp;n,&amp;s); build(); dinic(); printf("%d",ans); return 0;&#125;int K(gg());int main()&#123;;&#125; 球队收益传送门题解：对于单独一支球队来说，假设其已经赢了n场，输了m场。当其再赢 一场时，增加的收益为Ci((n+1)^2-n^2)，即Ci(2n+1)，输了同理。且每 赢一场或输一场增加的收益都是递增的。所以我们可以直接统计每支球队接 下来要比赛的局数，并分别为赢了或输了第几场比赛建边，因为收益递增， 且求最小费用，所以，一定是按照赢或输的累积次数流的。 对于一场比赛来说，只有两种结果，所以要对其建一条容量为一的入边，并建两条容量为1的出边，分别指向两种结果。 但这样，对于其中一种结果，容量为一，不能分别流向两支球队去修改各自的收益。又不可增大原来决定结果的三条边的流量，因为这样会出现，流同时流向两种结果的情况，不合法。 所以，我们只修改获胜球队(或失败球队)的收益。最初，我们先将一个球队的总收益算成接下来都会输的结果，这样每赢一场增加的收益就是Ci×((n+1)^2-n^2)- Di×((m+1)^2-m^2)，问题就解决了。 剪刀石头布传送门题解：此题和上一题的思路相同。需要注意到的是，对于任意三个人来说只有两种情况。三个人形成一个环，题中所示。其中一个战胜了另外两个人，另两个人随便。所以最后环的数目为，所有三个人的组合减去∑(i 1~n)c(f[i],2)，其中f[i]为第i个人战胜的人的数量。这样对于i来说，赢第n个人，环总数就需要减去n-1.所以仍需对赢第n个人建一条边。但输了的话不需要修改结果，所以无需将输赢结果合并，赢了直接修改。 总结？其实上面这一圈全是Ctrl+c&amp;Ctrl+v来的如果我还能打出来这些题的话，我就粘代码= =听得一脸茫然啊喂 彩蛋据说dalao就是聪聪，那么聪聪是谁呢~聪聪的世界嘿嘿嘿~（话说这样会不会被打死QAQ）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D4总结]]></title>
    <url>%2F2017%2F07%2F28%2F26%2F</url>
    <content type="text"><![CDATA[考试爆零了，不开心，打了两道自己以为是正解的东西，打了两道样例骗分，结果发现并没有给样例分= =，自己以为的正解也打挂了，所以就很= =但是没办法啊，自己弱也不能怪谁，考试这东西有时候也很玄学。值得高兴的是，我今天终于改完了四道题：T1 奇怪的道路T2 是老师原创题，就不发题解了，本以为自己A了的概率与期望，然而还是爆零= =T3 藏宝图T4 月光的魔法 生活今天就不写刷题篇了，毕竟基本融入了考试篇- -今天整天都在下雨，本来是很想出去在雨里散步的，然后我看看我的脚，嗯还是算了吧- -照例让渊渊xyz和同桌hww帮我买饭，晚饭时还以为雨停了，就出了机房，然而雨还不小， 正在门口思考人生时，mk大佬过来送了把伞，心里还是很暖的，虽然伤口湿了有点担心，但是还是不赖。下雨的时候散步，我是很喜欢的，反正现在跑不了，又不得不打着伞，那就低头看路吧，可不要踩到路上的蜗牛，下了雨，蜗牛们都爬出来了，一个个脆弱的生命爬出来也不容易，不如就慢点走，让蜗牛带着自己散步。 唱首歌？今天下雨了，来一首《在雨中》吧 在雨中看见你的身影那么温暖那么悲伤还记得我们去看电影那个故事感人肺腑在这场 淅沥沥 哗啦啦 纷纷扬 的雨中我们还能不能想从前那样 紧紧相拥在一切 过往的 流逝的 永远的 今天我们还能不能想从前那样 抱在雨中 随便唱吧，反正也没在调上过]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vijos1883 月光的魔法]]></title>
    <url>%2F2017%2F07%2F28%2F25%2F</url>
    <content type="text"><![CDATA[题目传送门背景 影几欺哄了众生了天以外——月儿何曾圆缺描述 有些东西就如同月光的魔法一般.Luke是爱着vijos的.他想为自己心爱的东西画些什么.就画N个圆吧.把它们的圆心都固定在x轴上.圆与圆.为了爱,两两不能相交.为了爱,它们可以互相贴在一起.内切或外切,都是允许的.vijos的美丽,在于人心.vijos的孩子们,一定能告诉大家:Luke画的圆究竟把平面分割成了多少块?月光恬美地洒在大地上.Luke知道,如果什么都不画,平面就只有一块.多美呢!Luke知道,只画一个圆,平面就分成了两块.也很美呢!但Luke还是要多画一些的,因为他真的深爱着vijos呢. INPUT输入数据第一行:输出一个整数N,1&lt;=N&lt;=300,000.表示圆的个数.之后N行,每一行有2个整数,x[i]和r[i]表示圆心固定在x[i]的位置,半径为r[i].-1,000,000,000&lt;=x[i]&lt;=1,000,000,0001&lt;=r[i]&lt;=1,000,000,000所有圆都是唯一的,不会出现重叠. OUTPUT输出只有一行,要求输出平面被分割成了多少块. SAMPLEINPUT47 5-9 1111 90 20 OUTPUT6 解题报告本次考试觉得唯一能A的一道题 （唯一能拿分的题吧啊喂），然而还是打挂了- -正解：我们考虑一下每个圆对答案的贡献，当它只是单独的一个圆时，它只把整个平面分割成圆内与圆外两部分，故贡献为1，同理，各种内切与外切也没有什么影响，但我们考虑，如果一个圆被沿直径一个点不差的被分开，它自己就又被分成两个部分，贡献就为2。如何判断呢，显然10^9的坐标是无法正常处理的，所以我们需要离散，用线段树维护区间被覆盖的点，把圆压成线段，每加入一个线段，就判断该区间是否已经被覆盖，假如被覆盖，说明该圆已经被沿直径分开了，那么它的贡献为2，否则为1.你以为这样就结束了？NONONO（莫名中二= =）。我们考虑这样一种情况，我们已经有了两个圆，一个占领了1~2，一个占领了3~4，我们现在要加入一个1~4的圆，首先，我们自然会查询1~4的总权值，得到4，是不是就会认为1~4全部覆盖然后开心的加了2？显然是错误的，2~3这一段区间并未被覆盖，但我们认为它被覆盖了，那么我们如何处理呢？我们可以把每个点劈成两半，一个称为该点的左半点，一个称为该点的右半点，那么当两个圆切于该点时，自然可以认为，一个圆覆盖了左半点，一个圆覆盖了右半点，此时再按上面那种方法判断，就啥事也没有啦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;inline int read()&#123; int sum(0),f(1); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()) if(ch=='-') f=-1; for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+ch-'0',ch=getchar()); return sum*f;&#125;map&lt;int,int&gt;ma;struct node&#123; int l,r; friend bool operator&lt;(const node &amp;a,const node &amp;b)&#123; return (a.r-a.l)&lt;(b.r-b.l); &#125;&#125;a[300001];int n;int tmp[600001];int cnt;int sum[600001&lt;&lt;3],add[600001&lt;&lt;3];inline void pushup(int i)&#123; sum[i]=sum[i&lt;&lt;1]+sum[i&lt;&lt;1|1];&#125;inline void pushdown(int i,int len)&#123; if(add[i])&#123; add[i&lt;&lt;1]=add[i]; add[i&lt;&lt;1|1]=add[i]; sum[i&lt;&lt;1]=add[i]*(len-(len&gt;&gt;1)); sum[i&lt;&lt;1|1]=add[i]*(len&gt;&gt;1); add[i]=0; &#125;&#125;inline void update(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&gt;rr) return; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; add[i]=c; sum[i]=c*(r-l+1); return; &#125; pushdown(i,r-l+1); int mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update(ll,rr,c,l,mid,i&lt;&lt;1); if(mid&lt;rr) update(ll,rr,c,mid+1,r,i&lt;&lt;1|1); pushup(i);&#125;inline int query(int ll,int rr,int l,int r,int i)&#123; if(ll&gt;rr) return 0; if(ll&lt;=l&amp;&amp;r&lt;=rr) return sum[i]; pushdown(i,r-l+1); int mid((l+r)&gt;&gt;1); int ret(0); if(ll&lt;=mid) ret+=query(ll,rr,l,mid,i&lt;&lt;1); if(mid&lt;rr) ret+=query(ll,rr,mid+1,r,i&lt;&lt;1|1); return ret;&#125;int ans(1);int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; int x(read()),r(read()); a[i].l=x-r,a[i].r=x+r; tmp[++cnt]=a[i].l,tmp[++cnt]=a[i].r; &#125; sort(tmp+1,tmp+cnt+1); cnt=0; for(int i=1;i&lt;=(n&lt;&lt;1);i++) if(!ma.count(tmp[i])) ma[tmp[i]]=++cnt; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; a[i].l=ma[a[i].l]&lt;&lt;1; a[i].r=(ma[a[i].r]&lt;&lt;1)-1;//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;l&lt;&lt;' '&lt;&lt;r&lt;&lt;endl; if(query(a[i].l,a[i].r,1,n&lt;&lt;2,1)==a[i].r-a[i].l+1) ans+=2; else ans++; update(a[i].l,a[i].r,1,1,n&lt;&lt;2,1); &#125; printf("%d",ans);&#125; 话说我当时用线段建了个图，然后dfs，现在想想也是蠢= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[藏宝图]]></title>
    <url>%2F2017%2F07%2F28%2F24%2F</url>
    <content type="text"><![CDATA[题目codeforces472D加强版，原题传送门本题在原题基础上加了一问，然而就是这一问把我搞炸了= =Czy爬上黑红树，到达了一个奇怪的地方……Czy发现了一张奇怪的藏宝图。图上有n个点，m条无向边。已经标出了图中两两之间距离dist。但是czy知道，只有当图刚好又是一颗树的时候，这张藏宝图才是真的。如果藏宝图是真的，那么经过点x的边的边权平均数最大的那个x是藏着宝物的地方。请计算这是不是真的藏宝图，如果是真的藏宝之处在哪里。 INPUT输入数据第一行一个数T,表示T组数据。对于每组数据，第一行一个n，表示藏宝图上的点的个数。接下来n行,每行n个数，表示两两节点之间的距离。 OUTPUT输出一行或两行。第一行”Yes”或”No”，表示这是不是真的藏宝图。若是真的藏宝图，第二行再输出一个数，表示哪个点是藏宝之处。 SAMPLEINPUT230 7 97 0 29 2 030 2 72 0 97 9 0 OUTPUTYes1Yes3 解题报告考试时只打出了第一问，还是O(n³)的复杂度，自然爆了零= =正解：首先我们考虑第一问，我们有了每两两点之间的距离，并想办法用其判断这个图是否是一棵树，我们想，在一棵树中，每两点之间路径是唯一的，故路径长度即为路径所经过所有边的长度之和,那么我们利用所给距离建出最小生成树，假如该图为树，那么最小生成树即为本身，假如不是，那么两点间距离一定会有变化，这些利用dfs什么的就可以做到了，顺便还可以建成图。这里需要注意的是，kruskal会被卡，要用prim （人题目给你矩阵还强行用kruskal也是醉），虽然突然不会prim了- -接下来是第二问，那就很简单了- -，建完图，一求边权平均数就可以了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long L;inline L read()&#123; L sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; L s,e,n; L w;&#125;a[6001];L pre[2501],tot;inline void insert(L s,L e,L w)&#123; a[++tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot;&#125;L T,n;L dis[2501][2501],dis1[2501],dis2[2501][2501];L fa[2501];bool vis[2501];L degree[2501];double num[2501];inline void clear()&#123; tot=0; memset(pre,-1,sizeof(pre)); memset(dis,0,sizeof(dis)); memset(dis1,0x7f,sizeof(dis1)); memset(dis2,0,sizeof(dis2)); memset(fa,0,sizeof(fa)); memset(vis,0,sizeof(vis)); memset(degree,0,sizeof(degree)); memset(num,0,sizeof(num));&#125;inline void prim()&#123; dis1[1]=0; for(L i=1;i&lt;=n;i++)&#123; L k(0); for(L j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis1[j]&lt;dis1[k]) k=j; vis[k]=1; for(L j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[k][j]&lt;dis1[j]) dis1[j]=dis[k][j],fa[j]=k; &#125;&#125;inline void build()&#123; for(L i=2;i&lt;=n;i++)&#123; insert(i,fa[i],dis1[i]); insert(fa[i],i,dis1[i]); degree[i]++,degree[fa[i]]++; &#125;&#125;inline void dfs(L start,L now,L fa,L deep)&#123; for(L i=pre[now];i!=-1;i=a[i].n)&#123; L e(a[i].e); if(e==fa) continue; dis2[start][e]=deep+a[i].w; dfs(start,e,now,deep+a[i].w); num[now]+=a[i].w; num[e]+=a[i].w; &#125;&#125;inline bool judge()&#123; for(L i=1;i&lt;=n;i++) for(L j=1;j&lt;=n;j++) if(i!=j) if(dis[i][j]!=dis2[i][j]&amp;&amp;dis2[i][j]&gt;0) return false; return true;&#125;int main()&#123;// freopen("1.in","r",stdin);// freopen("1.out","w",stdout); T=read(); while(T--)&#123; clear(); n=read(); for(L i=1;i&lt;=n;i++)&#123; for(L j=1;j&lt;=n;j++) dis[i][j]=read(); dis[i][i]=0x7fffffff; &#125; if(n==1)&#123; puts("Yes"); puts("1"); continue; &#125; prim(); build(); for(L i=1;i&lt;=n;i++) dfs(i,i,-1,0); if(!judge())&#123; puts("No"); continue; &#125; puts("Yes"); double mx(0); L ans(0); for(L i=1;i&lt;=n;i++)&#123; num[i]/=(double)degree[i]; if(num[i]&gt;mx) mx=num[i],ans=i; &#125; printf("%d\n",ans); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Jxoi2012] 奇怪的道路]]></title>
    <url>%2F2017%2F07%2F28%2F23%2F</url>
    <content type="text"><![CDATA[题目传送门小宇从历史书上了解到一个古老的文明。这个文明在各个方面高度发达，交通方面也不例外。考古学家已经知道，这个文明在全盛时期有n座城市，编号为1..n。m条道路连接在这些城市之间，每条道路将两个城市连接起来，使得两地的居民可以方便地来往。一对城市之间可能存在多条道路。据史料记载，这个文明的交通网络满足两个奇怪的特征。首先，这个文明崇拜数字K，所以对于任何一条道路，设它连接的两个城市分别为u和v，则必定满足1 &lt;=|u - v| &lt;= K。此外，任何一个城市都与恰好偶数条道路相连（0也被认为是偶数）。不过，由于时间过于久远，具体的交通网络我们已经无法得知了。小宇很好奇这n个城市之间究竟有多少种可能的连接方法，于是她向你求助。方法数可能很大，你只需要输出方法数模1000000007后的结果。 INPUT输入共一行，为3个整数n，m，K。 OUTPUT输出1个整数，表示方案数模1000000007后的结果。 SAMPLEINPUT13 4 1 OUTPUT13 INPUT24 3 3 OUTPUT24 解题报告考试时候想到了DP，一看数据范围也想到了状压，然而就是不会打，果然我DP就是弱啊- -正解：仍然考虑状压，将i-K到i的度的奇偶性压成一维，设f[i][j][k][l]表示到点i，用了j条边，i-K的奇偶性状态为k，当前处理i-K+l和i之间的连边。如果这条边不连,可以转移到f[i][j][k][l+1].如果这条边连,可以转移到f[i][j][k^(1&lt;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D3总结]]></title>
    <url>%2F2017%2F07%2F27%2F22%2F</url>
    <content type="text"><![CDATA[考试集训第一次考试，然而- -总共四道题，两道打了DFS，一道暴力，一道输出样例乱搞，都是泪啊- -目前只改了三道，回头改完那道题再上题解吧- -T2 [Poi2010]Monotonicity 2T3 [中山市选2011]杀人游戏T4 弱题说真的，感觉自己好弱啊- -，暴力只能打最基本的暴力，自己稍微多想一点就能拿多点分的暴力就是没想到。 刷题今天改题改的是真艰难- -，三颗权值线段树优化DP，tarjan乱搞还要各种诡异DFS，矩阵快速幂还要继续优化，我也是开了眼- -还有道大大大爆搜没有打出来，可能要等到明天了- -不过收获还是不小的，至少调的时候发现map用于结构体的特殊用法 （卡了我一个小时啊喂） ，明天准备尝试一下通过改动重载小于号来进行对map的奇奇怪怪的优化 （基本不可能啊喂） 生活心好累啊，本来还有点斗志昂扬，结果现在被搞得只想回家放假- -，一点都不想继续了，现在想想，当年为什么选择hz，又为什么选择OI选择hz这个事，我能后悔到我死，但加入茫茫OIer中的一员，我到死都不会后悔。最浅的一层，OI兴许能让我早点摆脱hz这个鬼地方，但摸着我这颗心讲，OI是再也不可以放下的了，它让我不再平凡的活，像那千千万万人一样，挤过那座我所深深痛恨的独木桥，它让我站在更高，人更少的山头上眺望远方与未来，它让我与这些OIer们一起行走在路上，坚守着自己心中的憧憬与渴望。可能这也是生活，给你欢喜，也给你忧愁。]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[弱题]]></title>
    <url>%2F2017%2F07%2F27%2F21%2F</url>
    <content type="text"><![CDATA[题目有M个球，一开始每个球均有一个初始标号，标号范围为1～N且为整数，标号为i的球有ai个，并保证Σai = M。 每次操作等概率取出一个球（即取出每个球的概率均为1/M），若这个球标号为k（k &lt; N），则将它重新标号为k + 1；若这个球标号为N，则将其重标号为1。（取出球后并不将其丢弃）现在你需要求出，经过K次这样的操作后，每个标号的球的期望个数。 INPUT第1行包含三个正整数N，M，K，表示了标号与球的个数以及操作次数。第2行包含N个非负整数ai，表示初始标号为i的球有ai个。 OUTPUT应包含N行，第i行为标号为i的球的期望个数，四舍五入保留3位小数 SAMPLEINPUT2 3 23 0 OUTPUT1.6671.333 解题报告弱题一点都不弱好吧= =，这题考试时打了个暴力，连不带优化的矩阵快速幂都没想出来= =正解：设f[i][j]表示第i个时间段，第j种的期望数量。首先，我们可以轻松地得到一个递推式子： f[i][j]=f[i-1][j-1]/m-f[i-1][j]+f[i-1][j] 正确性是很显然的，因为当前这个状态是由前一个转移过来，自己转移出去以及原来就有的数得到的，继续由一个高（ji）深（ben）的数学定理——乘法分配律可以得到： f[i][j]=(m-1)/m*f[i-1][j]+f[i-1][j-1]/m 那么显然，f[i][j]只与f[i-1]时的状态有关，那么显然我们可以去掉一维,从而得到一个极其简单的递推关系，就可以用矩阵快速幂来优化啦。我们自然可以构造出这样一个矩阵（以3*3为例）：| (m-1)/m | 0 | 1/m || ————- |:————-:| —————-:|| 1/m | (m-1)/m | 0 || 0 | 1/m | (m-1)/m |但是显然普通的矩阵快速幂的复杂度是O(n³logk)，会炸，所以我们需要优化。那么显然我们可以观察到，该矩阵的每一行，都可以由第一行平移得到，那么我们只需要维护第一行，便可推出整个矩阵，从而将复杂度将为O(能过) O(n²logk)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;int n,m,k;double a[1001][1001],b[1001];double tmp[1001];inline void multi_self()&#123; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) tmp[i]+=a[1][j]*a[j][i]; for(int i=1;i&lt;=n;i++) a[1][i]=tmp[i]; for(int i=2;i&lt;=n;i++)&#123; for(int j=2;j&lt;=n;j++) a[i][j]=a[i-1][j-1]; a[i][1]=a[i-1][n]; &#125;&#125;inline void multi_ea()&#123; memset(tmp,0,sizeof(tmp)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) tmp[i]+=b[j]*a[i][j]; for(int i=1;i&lt;=n;i++) b[i]=tmp[i];&#125;int main()&#123;// freopen("data.in","r",stdin);// freopen("data.out","w",stdout); n=read(),m=read(),k=read(); for(int i=1;i&lt;=n;i++)&#123; int x(read()); b[i]=x*1.0; &#125; a[1][1]=(double)(m-1)/(double)m; a[1][n]=1.0/(double)m; for(int i=2;i&lt;=n;i++) a[i][i-1]=1.0/(double)m,a[i][i]=(double)(m-1)/(double)m; while(k)&#123; if(k&amp;1) multi_ea(); multi_self(); k&gt;&gt;=1; &#125; for(int i=1;i&lt;=n;i++) printf("%.3lf\n",b[i]);&#125; ps:写文章时，因为不会用Markdown语法加表格，活活卡了我一个小时= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Poi2010]Monotonicity 2]]></title>
    <url>%2F2017%2F07%2F27%2F20%2F</url>
    <content type="text"><![CDATA[题目给出N个正整数a[1..N]，再给出K个关系符号（&gt;、&lt;或=）s[1..k]。 选出一个长度为L的子序列（不要求连续），要求这个子序列的第i项和第i+1项的的大小关系为s[(i-1)mod K+1]。求出L的最大值。 INPUT第一行两个正整数，分别表示N和K (N, K &lt;= 500,000)。第二行给出N个正整数，第i个正整数表示a[i] (a[i] &lt;= 10^6)。第三行给出K个空格隔开关系符号（&gt;、&lt;或=），第i个表示s[i]。 OUTPUT一个正整数，表示L的最大值。 SAMPLEINPUT7 32 4 3 1 3 5 3&lt; &gt; = OUTPUT6 解题报告考试时连最最最简单的DP都没想出来，就打了个DFS- -正解：我们先考虑只有一种符号的情况，比如说考虑&lt;，那么不就变成了求最长上升子序列吗。同样的，我们扩展至三种符号：123456789101112for(int i=1;i&lt;=n;i++)&#123; f[i]=1; for(int j=1;j&lt;=i-1;j++)&#123; int tmp(f[j]%k+1); if(op[tmp]=='='&amp;&amp;a[j]==a[i]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1; if(op[tmp]=='&gt;'&amp;&amp;a[j]&gt;a[i]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1; if(op[tmp]=='&lt;'&amp;&amp;a[j]&lt;a[i]&amp;&amp;f[j]+1&gt;f[i]) f[i]=f[j]+1; &#125;&#125; 这就是最最最简单的DP，然而我们知道，这玩意是O(n²)的复杂度，显然会T，那么我们就需要优化一下了。我们发现，转移时有O(n)的复杂度来找最大值，那么我们想，是否可以把这个过程优化呢？自然可以，我们的目的在于找到权值符合条件的最大f值，所以，我们需要一个新的东西来完成它： 权值线段树这是一个神奇的数据结构- -，好吧，也不怎么神奇，它在这道题里是以权值为下标，存入该点最优解的一种线段树，它就可以完成这个伟大的任务啦。我们需要3棵树（其实2棵也可以，相等的那个用数组模拟即可实现，只是我比较懒- -），每一棵树存以该符号为后面所接符号的权值的最优解（好绕啊- -），这样我们在找的时候，取出每棵树中符合权值条件的最优解，三解进行比较，选出最优以确定符号，继续转移并更新相应的线段树即可。（我语文表达能力好弱啊）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;inline char init()&#123; char ch(getchar()); for(;ch!='='&amp;&amp;ch!='&gt;'&amp;&amp;ch!='&lt;';ch=getchar()); return ch;&#125;inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;int n,k;int a[500001],op[500001];int tr_d[4000001],tr_x[4000001],tr_e[4000001];int ad_d[4000001],ad_x[4000001],ad_e[4000001];inline void pushup_d(int i)&#123; tr_d[i]=my_max(tr_d[i&lt;&lt;1],tr_d[i&lt;&lt;1|1]);&#125;inline void pushup_x(int i)&#123; tr_x[i]=my_max(tr_x[i&lt;&lt;1],tr_x[i&lt;&lt;1|1]);&#125;inline void pushup_e(int i)&#123; tr_e[i]=my_max(tr_e[i&lt;&lt;1],tr_e[i&lt;&lt;1|1]);&#125;inline void pushdown_d(int i)&#123; if(ad_d[i])&#123; ad_d[i&lt;&lt;1]=ad_d[i]; ad_d[i&lt;&lt;1|1]=ad_d[i]; tr_d[i&lt;&lt;1]=ad_d[i]; tr_d[i&lt;&lt;1|1]=ad_d[i]; tr_d[i]=ad_d[i]; ad_d[i]=0; &#125;&#125;inline void pushdown_x(int i)&#123; if(ad_x[i])&#123; ad_x[i&lt;&lt;1]=ad_x[i]; ad_x[i&lt;&lt;1|1]=ad_x[i]; tr_x[i&lt;&lt;1]=ad_x[i]; tr_x[i&lt;&lt;1|1]=ad_x[i]; tr_x[i]=ad_x[i]; ad_x[i]=0; &#125;&#125;inline void pushdown_e(int i)&#123; if(ad_e[i])&#123; ad_e[i&lt;&lt;1]=ad_e[i]; ad_e[i&lt;&lt;1|1]=ad_e[i]; tr_e[i&lt;&lt;1]=ad_e[i]; tr_e[i&lt;&lt;1|1]=ad_e[i]; tr_e[i]=ad_e[i]; ad_e[i]=0; &#125;&#125;inline void update_d(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; ad_d[i]=c; tr_d[i]=c; return; &#125; pushdown_d(i); int mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update_d(ll,rr,c,l,mid,i&lt;&lt;1); if(rr&gt;mid) update_d(ll,rr,c,mid+1,r,i&lt;&lt;1|1); pushup_d(i);&#125;inline void update_x(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; ad_x[i]=c; tr_x[i]=c; return; &#125; pushdown_x(i); int mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update_x(ll,rr,c,l,mid,i&lt;&lt;1); if(rr&gt;mid) update_x(ll,rr,c,mid+1,r,i&lt;&lt;1|1); pushup_x(i);&#125;inline void update_e(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; ad_e[i]=c; tr_e[i]=c; return; &#125; pushdown_e(i); int mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update_e(ll,rr,c,l,mid,i&lt;&lt;1); if(rr&gt;mid) update_e(ll,rr,c,mid+1,r,i&lt;&lt;1|1); pushup_e(i);&#125;inline int query_d(int ll,int rr,int l,int r,int i)&#123; if(ll&gt;rr) return 0; if(ll&lt;=l&amp;&amp;r&lt;=rr) return tr_d[i]; pushdown_d(i); int mid((l+r)&gt;&gt;1); int ret(0); if(ll&lt;=mid) ret=my_max(ret,query_d(ll,rr,l,mid,i&lt;&lt;1)); if(rr&gt;mid) ret=my_max(ret,query_d(ll,rr,mid+1,r,i&lt;&lt;1|1)); return ret;&#125;inline int query_x(int ll,int rr,int l,int r,int i)&#123; if(ll&gt;rr) return 0; if(ll&lt;=l&amp;&amp;r&lt;=rr) return tr_x[i]; pushdown_x(i); int mid((l+r)&gt;&gt;1); int ret(0); if(ll&lt;=mid) ret=my_max(ret,query_x(ll,rr,l,mid,i&lt;&lt;1)); if(rr&gt;mid) ret=my_max(ret,query_x(ll,rr,mid+1,r,i&lt;&lt;1|1)); return ret;&#125;inline int query_e(int ll,int rr,int l,int r,int i)&#123; if(ll&gt;rr) return 0; if(ll&lt;=l&amp;&amp;r&lt;=rr) return tr_e[i]; pushdown_e(i); int mid((l+r)&gt;&gt;1); int ret(0); if(ll&lt;=mid) ret=my_max(ret,query_e(ll,rr,l,mid,i&lt;&lt;1)); if(rr&gt;mid) ret=my_max(ret,query_e(ll,rr,mid+1,r,i&lt;&lt;1|1)); return ret;&#125;int f[500001];int mx(0);int main()&#123; n=read(),k=read(); for(int i=1;i&lt;=n;i++) a[i]=read(),mx=my_max(mx,a[i]); for(int i=1;i&lt;=k;i++)&#123; char ch(init()); if(ch=='&gt;') op[i]=1; if(ch=='&lt;') op[i]=2; if(ch=='=') op[i]=3; &#125; f[1]=1; if(op[1]==1) update_d(a[1],a[1],f[1],1,mx,1); if(op[1]==2) update_x(a[1],a[1],f[1],1,mx,1); if(op[1]==3) update_e(a[1],a[1],f[1],1,mx,1); for(int i=2;i&lt;=n;i++)&#123; int now(a[i]); int ans_d(query_d(now+1,mx,1,mx,1)); int ans_x(query_x(1,now-1,1,mx,1)); int ans_e(query_e(now,now,1,mx,1)); int ans(my_max(my_max(ans_d,ans_x),ans_e)); f[i]=ans+1; int o(op[ans%k+1]);//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;f[i]&lt;&lt;' '&lt;&lt;o&lt;&lt;endl; if(o==1) update_d(now,now,f[i],1,mx,1); if(o==2) update_x(now,now,f[i],1,mx,1); if(o==3) update_e(now,now,f[i],1,mx,1); &#125; int mxx(0); for(int i=1;i&lt;=n;i++) mxx=my_max(mxx,f[i]); printf("%d",mxx);&#125; 写的极其丑- -，毕竟三颗线段树乱搞凑合着看吧，其实理解了之后，一颗线段树，加不同的域，对传的参数进行处理，就可以达到三颗线段树的效果]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[中山市选2011]杀人游戏]]></title>
    <url>%2F2017%2F07%2F27%2F19%2F</url>
    <content type="text"><![CDATA[题目 一位冷血的杀手潜入 Na-wiat，并假装成平民。警察希望能在 N 个人里面，查出谁是杀手。 警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？ INPUT第一行有两个整数 N,M。接下来有 M 行，每行两个整数 x,y，表示 x 认识 y（y 不一定认识 x,例如胡锦涛同志）。 OUTPUT仅包含一行一个实数，保留小数点后面 6 位，表示最大概率。 SAMPLEINPUT5 41 21 31 41 5 OUTPUT0.800000 解题报告考试时没想出来，随便打的输出样例- -正解：警察只有两种结果——查到犯人或者死，而死一定是包含在“调查未知身份的人”，也就是说调查未知身份的人越多，死亡概率越高，所以我们要求警察如何尽可能少调查未知身份的人那么问题就很简单了，我们发现对于一个强连通分量，我们可以把他们看作一个人，因为调查了其中一个，剩余的都可以安全到达（正确性显然，因为你只要安全调查了其中的一个人，你就可以通过每次确认安全的人从而调查整个强连通分量），那么我们就可以tarjan一下，那么我们调查的对象就为缩点后入度为0的点（因为你无法从其他点通向这个点，你只能通过调查其中一个未知身份的人来调查整个强连通分量，如果警察RP不好，第一个选中杀手，警察就GG了），所以调查的未知身份的人数就是这些点的数量。坑点：存在这样一种情况，至少有一个点，且只有一个人，而且没人认识他，他也不认识别人，或者他认识的每个人都能被除他以外的其他人所认识（即入度&gt;1），那么我们调查完其他人后，他就是杀手（正确性显然，对于第一种情况，考虑n=1就行，对于第二种情况，他认识的人已经被调查过了，而其他人自然也被调查过，那么他自己就是剩下未调查的唯一可能的杀手）。那么如何处理呢？进行特判，顺便dfs一下，判断是否属于这种情况就可以啦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int s,e,n;&#125;a[300001],b[100001];int pre[100001],tot;int adj[100001],ttt;inline void insert(int s,int e)&#123; a[++tot].s=s; a[tot].e=e; a[tot].n=pre[s]; pre[s]=tot;&#125;inline void add(int s,int e)&#123; b[++ttt].s=s; b[ttt].e=e; b[ttt].n=adj[s]; adj[s]=ttt;&#125;int n,m;int stack[100001],top;int cnt,low[100001],dfn[100001],bl[100001],qlt;bool vis[100001];int size[100001];inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline void tarjan(int u)&#123; cnt++; vis[u]=1; low[u]=dfn[u]=cnt; stack[++top]=u; for(int i=pre[u];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(!dfn[e])&#123; tarjan(e); low[u]=my_min(low[u],low[e]); &#125; else if(vis[e]) low[u]=my_min(low[u],dfn[e]); &#125; if(low[u]==dfn[u])&#123; int tmp; qlt++; while(1)&#123; tmp=stack[top--]; bl[tmp]=qlt; vis[tmp]=0; if(tmp==u) break; &#125; &#125;&#125;bool flag[100001];inline void uni(int u)&#123;//坑点处理dfs for(int i=adj[u];i!=-1;i=b[i].n)&#123; int e(b[i].e); if(!vis[e])&#123; vis[e]=1; uni(e); size[u]+=size[e]; &#125; &#125;&#125;int ans(0);int ind[100001];int main()&#123;// freopen("killer.in","r",stdin);// freopen("killer.out","w",stdout); memset(pre,-1,sizeof(pre)); memset(adj,-1,sizeof(adj)); n=read(),m=read(); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); insert(x,y); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) size[bl[i]]++; for(int i=1;i&lt;=m;i++)&#123; int s(a[i].s),e(a[i].e); if(bl[s]!=bl[e]) add(bl[s],bl[e]),ind[bl[e]]++; &#125; for(int i=1;i&lt;=qlt;i++) if(!ind[i])&#123;//坑点特判 uni(i); if(size[i]==1)&#123; ans=-1; break; &#125; &#125; for(int i=1;i&lt;=qlt;i++) if(ind[i]==0) ans++; printf("%.6lf",(double)(n-ans)/(double)n);&#125; 哀民生之多艰啊- -]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D2总结]]></title>
    <url>%2F2017%2F07%2F26%2F18%2F</url>
    <content type="text"><![CDATA[%dalao大佬讲课笔记大佬AntiLeaf来讲概率&amp;期望，然后——成功变为 不可做 题选讲= =真的好难啊呜呜呜~~o(&gt;_&lt;)o ~~不过收获还是极大的，至少知道了概率还能这么玩- - 切题COGS上就A了4道，虽然3道都上了榜，但是都是水题啊喂- -不过还是感觉可以的，学会了笛卡尔树、带权并查集、概率与期望，顺便把去年联赛的 换教室 A了（当年只会打个Floyed，然后读入还打错了啊喂，只拿了10分- -）然后终于明白了——SPFA不能用堆优化= =，我这样错误地认为了半年= = 生活3顿饭，两顿都是让同学买回机房吃的，早饭是因为脚伤了懒，午饭是因为下雨怕伤口沾水（借口好多2333）日常与同桌互相嘲讽2333，顺便交换一下手头上的军（tu）火（bao）（xyz神军火get√）日常上网搜寻正常的blog主题，然而就是找不到更满意的，难道要自己写一个吗QWQ 话说今天雨下的好大，一阵一阵的，要是以前，早就坐不住去雨里浪了，然而- -我这脚你让我怎么进雨里啊喂其实也挺好，还有同桌hww&amp;渊渊xyz帮我买饭，也是很好的一件事呢 可能生活就是这样吧，欢喜与悲伤交替，我行走在世界的边缘，注视着它，感受着它，希望什么的，或许有，或许无毕竟 人生也如此不是么 继续背诗归去来兮辞（这不是辞嘛啊喂） 归去来兮，田园将芜胡不归？既自以心为形役，奚惆怅而独悲。悟已往之不谏，知来者之可追。实迷途其未远，觉今是而昨非。舟遥遥以轻飏，风飘飘而吹衣。问征夫以前路，恨晨光之熹微。 乃瞻衡宇，载欣载奔。僮仆欢迎，稚子候门。三径就荒，松菊犹存。携幼入室，有酒盈樽。引壶觞以自酌，眄庭柯以怡颜。倚南窗以寄傲，审容膝之易安。园日涉以成趣，门虽设而常关。策扶老以流憩，时矫首而遐观。云无心以出岫，鸟倦飞而知还。景翳翳以将入，扶孤松而盘桓。 归去来兮，请息交以绝游。世与我而相违，复驾言兮焉求？悦亲戚之情话，乐琴书以消忧。农人告我以春及，将有事于西畴。或命巾车，或棹孤舟。既窈窕以寻壑，亦崎岖而经丘。木欣欣以向荣，泉涓涓而始流。善万物之得时，感吾生之行休。 已矣乎！寓形宇内复几时？曷不委心任去留？胡为乎遑遑欲何之？富贵非吾愿，帝乡不可期。登东皋以舒啸，或执杖而耘籽。聊乘化以归尽，乐夫天命复奚疑！ （然而好像快忘了怎么背了）（心情怎样，就想起什么样的人，什么样的文）]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2017-7-26 大佬讲课笔记]]></title>
    <url>%2F2017%2F07%2F26%2F17%2F</url>
    <content type="text"><![CDATA[AntiLeaf大佬来讲课啦 完全 不可做 题的一天 NOI2016 区间大佬填坑= =传送门把所有区间按长度排序，从小到大扫每个区间显然最长的那个区间一定是随最小的区间单调增的，因此暴力拓展每个区间并用线段树求一下是否有被m个区间覆盖的点即可O(nlogn) 正经的主题——概率与期望基本工具DP&amp;&amp;GaussDP的状态定义常常体现“逆序”的特点状态之间不存在先后关系时往往需要解方程组特殊方程组的奇技淫巧= = bzoj1426传送门n种易拉罐，买第i次需要i元，假设每次买到的易拉罐种类都是随机的，问期望花多少钱能集齐所有易拉罐n&lt;=5×10^6（不要问我为啥粘了传送门还粘题，两位大佬的题目描述可能是奇奇怪怪的不一样呢） 本蒟蒻不就是n×∑(1/i)×average嘛（听取WA声一片- -） AntiLeaf设购买次数为x，则Ans=(E(x)+E(x²))/2因为x次，需要x(x+1)/2元E(x)=n∑(1/i)f[i]表示差i种易拉罐的期望次数，g[i]表示平方的期望f[i]=f[i+1]+n/i设之前的次数为x，获得第i种易拉罐还需要y次E((x+y)²)=E(x²+2xy+y²)=E(x²)+2E(x)E(y)+E(y²)我们已经知道E(x²)=g[i+1],E(x)=f[i+1],E(y)=n/i剩下的问题就是如何求E(y²)了从定义入手E(y²)=∑(k 1~∞)k²((n-i)/n)^(k-1)×(n/i)后面的东西硬推出通项（dalao的力量么= =） liu_runda我们可以在得到n种邮票后再计算费用,认为最后一张邮票的花费是1,倒数第二张邮票的花费是2,倒数第n张的花费是n,不难看出这样计算的费用是不变的.如果不这样转换,也可以认为每一次购买邮票的花费都是1,而每次购买邮票会使后面的每次购买的花费增加1,也就是总费用增加了剩余的购买次数元F[i]为买最后i张邮票的期望次数,C[i]为买最后i种邮票的期望花费(不包括得到前n-i种邮票使后i种邮票增加的花费)C[i]=(i/n)×卫龙+(1-i/n)×香爆脆（达哥的变量名= =）问卫龙和香爆脆是什么其实就是分类讨论卫龙=1(买1次)+F[i+1]（增加的费用）+C[i+1]香爆脆=1+F[i]+C[i]最终C[i]=n/i+f[i+1]+C[i+1]+(n-i)*f[i]/i这个费用提前计算的技巧还是有些用处的.例如网络流里 SCOI2007修车和NOI2012美食节再次说明概率和期望的题虽然有特性,但是和其他题的思路是相通的. 大佬出的水题有一个人在一个序列上闲逛，初始时这个人位于位置1，每次他有pi的概率停下来（pi只与当前位置有关），也有1-pi的概率继续走下去（这人闲得慌- -）如果他走到了序列的某一端，则他下次行走时会掉头往回走求这个人走的次数的期望在模10^9+7意义下的结果（意思是必须求出精确解）n&lt;=210^5直接处理这个人来回走的情况可能不太优美，我们可以直接把问题转化成这个人在一个环上沿固定方向走，把原序列除两端以外的部分复制一份并反向与原序列拼起来即可然后考虑环上的问题，定义f[i]表示从i开始走的期望步数，显然有f[i]=(1-p[i])(f[i+1]+1)（如果这个人按照1~n的方向走的话）然而这个转移出环了……注意到转移时的运算都是线性的，因此我们可以从n开始倒推f[i]=a[i]f[1]+b[i]，最后推到f[1]时即可得到一个关于f[1]的一元一次方程，直接解出来即可显然这个做法是O(n)的 水题增强版把刚才的环换成一棵有根树，每次如果不停下来则会随机选择一个儿子走过去，规定走到叶子节点后再走会回到根节点，其余均不变做法同上把有根树换成有根森林，回到根节点改成随机回到一个根节点，其余均不变建一个超（chao）级（shi）原点即可，其余做法同上把有根森林换成DAG，随机回到一个根节点改成随机回到一个入度为0的点，其余均不变建一个新点连向所有入度为0的点，其余做法还是同上…… CF464D World of Darkraft-2传送门翻译版= =：你在玩一个游戏，游戏中有k种装备，每件装备都有一个等级，初始时你拥有每种1级装备各一件你打算刷n只怪，每刷一只怪之后系统就会随机爆出一件装备随机方式是先等概率随机装备的种类，设你当前拥有的这种装备的等级为t，则系统会在1~t+1之间等概率随机装备的等级由于某些原因，你决定只在爆出的装备高于当前装备的等级时换上新装备并卖掉旧装备，否则直接卖掉爆出的装备，卖掉等级为t的装备可以得到t个金币求你刷n只怪后得到的金币数的期望n&lt;=10^5，k&lt;=100可以发现每种装备对答案的贡献都完全相同且互不影响，因此我们可以只求出一种装备对答案的贡献，最后乘上k即可一种装备的贡献可以用DP求解，设f[i,j]表示带着等级为j的装备再刷i只怪的期望收益（注意这里还是逆序定义），则有f[i,j]=((f[i-1,j]+(j+1)/2)×(j/(j+1))+(f[i-1,j+1]+j)/(j+1))/k+(f[i-1,j]×(k-1))/k（乱成啥了- -）按照这个方程DP可以做到O(n²)继续考虑如何优化DP的转移已经无法再优化了，因此我们可以尝试优化状态数注意到装备等级越高，再提升一级就越难，而刷n只怪之后装备的期望等级最多也是O(n^0.5)的，并且不难看出等级比O(n^0.5)高太多之后的概率就可以忽略不计了因此我们可以把第二维的范围限定为&lt;=一个O(n^0.5)级别的数，这样就可以把复杂度降到O(n^1.5)了 这道题告诉我们，做不要求输出精确解的概率/期望DP时可以忽略概率非常小的状态，通常可以起到卡常的作用，有时也能优化复杂度（比如这道题） CF696B Puzzles传送门有一棵n个点的有根树，从根开始对这棵树进行dfs，对于一个点访问它的所有儿子的顺序是随机的求每个点的时间戳的期望n&lt;=10^5我们都知道期望有线性性因此一个点的时间戳的期望=父亲的期望+兄弟对它的贡献+1对每个兄弟分别考虑，如果这个兄弟比它更早访问，对它的时间戳的贡献就是子树大小由于是随机访问，因此谁在前面的概率都是一样的一个点的期望=父亲的期望+兄弟子树大小之和/2+1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int s,e,n;&#125;a[100001];int pre[100001],tot;inline void insert(int s,int e)&#123; a[++tot].s=s; a[tot].e=e; a[tot].n=pre[s]; pre[s]=tot;&#125;int size[100001],fa[100001];double f[100001];int n;inline void dfs(int u)&#123; size[u]=1; for(int i=pre[u];i!=-1;i=a[i].n)&#123; int e(a[i].e); dfs(e); size[u]+=size[e]; &#125;&#125;inline void cal(int u)&#123; if(u!=1) f[u]=f[fa[u]]+(size[fa[u]]-size[u]-1)/2.0+1;// cout&lt;&lt;u&lt;&lt;' '&lt;&lt;f[u]&lt;&lt;endl; for(int i=pre[u];i!=-1;i=a[i].n) cal(a[i].e);&#125;int main()&#123; memset(pre,-1,sizeof(pre)); n=read(); for(int i=2;i&lt;=n;i++)&#123; int x(read()); fa[i]=x; insert(x,i); &#125; dfs(1); f[1]=1; cal(1); for(int i=1;i&lt;=n;i++) printf("%.1lf ",f[i]);&#125;//首道cf上的题留念- - GT考试出门右转大佬告诉我我那个鬼东西叫KMP自动机- -然而我瞎打的时候并不知道自动机= = 总结并不咋能听懂= =还需消化吸收= =ps:等我能做出来的时候在粘代码吧- -]]></content>
      <categories>
        <category>笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[HZOI 2016]简单的Treap]]></title>
    <url>%2F2017%2F07%2F26%2F16%2F</url>
    <content type="text"><![CDATA[题目Treap是一种平衡二叉搜索树，除二叉搜索树的基本性质外，Treap还满足一个性质： 每个节点都有一个确定的优先级，且每个节点的优先级都比它的两个儿子小(即它的优先级满足堆性质)。不难证明在节点的优先级都事先给定且互不相同时，对应的Treap有且仅有一个。现在，给定n个数和每个数对应的优先级，求出对应的以数的大小作为二叉搜索树比较依据的Treap的先序遍历结果。对先序遍历的定义是：先访问根节点，再访问左子树，最后访问右子树。 INPUT第一行一个数n表示数的个数。第二行n个数表示每个数的大小。第三行n个数表示每个数对应的优先级。 OUTPUT一行n个数，表示Treap的先序遍历结果(对于每个节点，输出对应的数)。 SAMPLEINPUT72 11 5 9 1 4 32 10 1 8 4 6 5 OUTPUT5 2 1 3 4 9 11 解题报告不要相信题目名称！！！这题卡Treap，用Treap会T掉俩点，那么我们就需要黑科技——笛卡尔树来解决问题了。 笛卡尔树笛卡尔树是一种同时满足二叉搜索树和堆的性质的数据结构。 可在一个数组上构造出来（时间复杂度可以达到O(n))。树中节点有几个属性， key（节点元素的大小）、index（节点在原数组中的索引）、left（左子节点）、right（右子节点）、parent（父节点）。 性质树中的元素满足二叉搜索树性质，要求按照中序遍历得到的序列为原数组序列树中节点满足堆性质，节点的key值要大于其左右子节点的key值 构造要求在给定的数组的基础上构造一棵笛卡尔树，这可以在O(n)的时间内完成。 其具体思路为：当按照index从1到n（或者从0到n-1）的顺序将数组中的每个元素插入到笛卡尔树中时，当前要被插入的元素的index值最大，因此根据二叉搜索的性质需要沿着当前已经完成的笛卡尔树的根的右子树链搜索。由于笛卡尔树要满足堆的性质（以最大堆为例），父节点的key值要大于子节点的key值，所以沿着树根的右子树链往下走，直到搜索到的节点的key值小于等于当前要插入节点的key值。此时，便找到了当前结点需要插入的位置，记为P。此时P下方的节点的key值肯定小于当前被插入节点的key，但是index也小于当前插入节点的index（即需要在二叉搜索树中当前结点之前的位置），所以将当前节点插入到P的位置，同时将以P为根的子树挂载到新插入的节点的左子树（为了保证P及其子树在新插入节点之前被二叉搜索）。实际实现的时候，可以采用栈的数据结构。栈中保存当前树中的从树根开始的右子节点链，根在栈底部。插入新元素的时候，从树的右子链的最末尾从下往上查找，直到找到第一个满足堆性质的节点（即找到的节点的key值大于当前需要插入的节点）。用栈来实现就是从栈顶不断弹出元素，直到栈顶的元素的key大于当前结点的key，然后将该节点入栈，同时将最后被弹出的节点的parent指向该节点，以及该节点的左子节点指向最后被弹出的节点。复杂度分析： 每个节点最多入栈一次，出栈一次，因此时间复杂度为 O(n) ps:其实没那么麻烦= =，几个数组乱抡就可以了 那么剩下的就很简单了，按关键字排个序，建树，然后乱搞- -123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum;&#125;struct node&#123; int val,key;//val为数的大小，key为优先级- - bool operator&lt;(const node &amp;a)const&#123; return val&lt;a.val; &#125;&#125;a[500001];int n;int stack[500001],top(0);int root,lc[500001],rc[500001];inline void print(int u)&#123; if(u==0) return; printf("%d ",a[u].val); print(lc[u]); print(rc[u]);&#125;int main()&#123; freopen("treap.in","r",stdin); freopen("treap.out","w",stdout); int __size__=128&lt;&lt;20; char *__p__=(char*)malloc(__size__)+__size__; __asm__("movl %0, %%esp\n"::"r"(__p__)); n=read(); for(int i=1;i&lt;=n;i++) a[i].val=read(); for(int i=1;i&lt;=n;i++) a[i].key=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++)&#123; stack[top+1]=0; while(top&amp;&amp;a[stack[top]].key&gt;a[i].key) top--; lc[i]=stack[top+1]; if(top==0) root=i; else rc[stack[top]]=i; stack[++top]=i; &#125; print(root);&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>笛卡尔树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假集训D1总结]]></title>
    <url>%2F2017%2F07%2F25%2F15%2F</url>
    <content type="text"><![CDATA[归来今天就这样回来了，虽然心里极其不想回来（暑假!@#的只有一天啊喂），但还是回来了，没办法，虽然不喜欢这个地方，但是机房却也是少数能给我安慰的地方，心再累，也没有办法了，不如好好集训= = %dalao今天下午AntiLeaf大佬给我们讲了一下午的呢~据说明天大佬还要给我们讲，好激动~，话说一直以来都认为叶子是个学姐- -，然而一看讲课的幻灯片，根本想不到他就是叶子啊喂- -不过大佬讲题的确是可以的，我终于知道,写着个数学式子让你求的不一定是数学题= = みらい(未来)未来这十来天，我们就要泡在机房里各种考试，各种刷题了- -还有两三个月就联赛了呢，一定要抓住集训机会呢 有时候就一直在想，自己的未来想是什么样子的，其实没有太多，目前的小目标是早日脱离hz，不滚去高考。再远一些，我想，可能就是老家的稻田与竹林吧。 不合时宜的我，要怎么办呢~ 今日收获终于会打线段树了蛤蛤蛤（记得前两天考试，树剖俩dfs打完，线段树不会打了，一脸茫然啊喂）顺便嘲讽了一圈同桌hww成功把爸妈带入COGS的海洋（hhhh）]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[COGS 2434]暗之链锁]]></title>
    <url>%2F2017%2F07%2F25%2F14%2F</url>
    <content type="text"><![CDATA[题目传说中的暗之连锁被人们称为Dark。Dark是人类内心的黑暗的产物，古今中外的勇者们都试图打倒它。经过研究，你发现Dark呈现无向图的结构，图中有N个节点和两类边，一类边被称为主要边，而另一类被称为附加边。Dark有N – 1条主要边，并且Dark的任意两个节点之间都存在一条只由主要边构成的路径。另外，Dark还有M条附加边。你的任务是把Dark斩为不连通的两部分。一开始Dark的附加边都处于无敌状态，你只能选择一条主要边切断。一旦你切断了一条主要边，Dark就会进入防御模式，主要边会变为无敌的而附加边可以被切断。但是你的能力只能再切断Dark的一条附加边。现在你想要知道，一共有多少种方案可以击败Dark。注意，就算你第一步切断主要边之后就已经把Dark斩为两截，你也需要切断一条附加边才算击败了Dark。 INPUT第一行包含两个整数N和M。之后N – 1行，每行包括两个整数A和B，表示A和B之间有一条主要边。之后M行以同样的格式给出附加边。 OUTPUT输出一个整数表示答案。 SAMPLEINPUT4 11 22 31 43 4 OUTPUT3 解题报告第一眼看这题，还以为要用每个点的度来做= =正经的解法：求出每条正经的边被多少条附加边(不正经的边？(雾))所覆盖，设其为x然后对每一条正经的边询问，只有x==0||x==1时，这条边才能被砍（正确性显然，因为如果x&gt;1,你就算砍了它，再砍一条覆盖它的附加边，也没啥用，无法使其不连通）当x==0时，m条边随便砍，故对答案的贡献为m当x==1时，只有砍了覆盖它的那条附加边才有用，故对答案的贡献为1 那么问题来了，咋求这个x呢？显然正经的边形成的是一棵树，那么我们就可以将边权下放到点权（为啥？好算啊= =），这样除了根，每个点都会有点权值，我们就可以用差分的思想来解决这个问题，dfs序跑一遍，修改时LCA-2,两端点+1（想想为什么？差分这东西，就是靠正负的抵消与修改后对区间和的影响来搞的，这样做的目的也就很明显了），那么该点权值自然就为从dfs序左端点到右端点的区间和。剩下的就十分简单了，乱搞出奇迹= =123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum;&#125;int n,m;struct edge&#123; int s,e,n;&#125;a[200001];int pre[100001],tot;inline void insert(int s,int e)&#123; a[++tot].s=s; a[tot].e=e; a[tot].n=pre[s]; pre[s]=tot;&#125;int fa[100001],dep[100001],size[100001],son[100001];inline void dfs1(int u)&#123; son[u]=0; for(int i=pre[u];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(e!=fa[u])&#123; fa[e]=u; dep[e]=dep[u]+1; dfs1(e); size[u]+=size[e]; if(size[e]&gt;size[son[u]]) son[u]=0; &#125; &#125;&#125;int cnt;int r[100001];int top[100001],id[100001],pos[100001];inline void dfs2(int u,int rt)&#123; top[u]=rt; id[u]=++cnt; pos[cnt]=u; if(son[u]) dfs2(son[u],rt); for(int i=pre[u];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(e!=fa[u]&amp;&amp;e!=son[u]) dfs2(e,e); &#125; r[u]=cnt;&#125;int sum[100001];inline int lowbit(int x)&#123; return x&amp;-x;&#125;inline void update(int pos,int c)&#123; while(pos&lt;=n)&#123; sum[pos]+=c; pos+=lowbit(pos); &#125;&#125;inline int su(int pos)&#123; int ret(0); while(pos)&#123; ret+=sum[pos]; pos-=lowbit(pos); &#125; return ret;&#125;inline int query(int l,int r)&#123; return su(r)-su(l-1);&#125;inline void swp(int &amp;a,int &amp;b)&#123; a^=b; b^=a; a^=b;&#125;inline int LCA(int x,int y)&#123; while(top[x]^top[y])&#123; if(dep[top[x]]&lt;dep[top[y]]) swp(x,y); x=fa[top[x]]; &#125; return dep[x]&lt;dep[y]?x:y;&#125;inline void change(int x,int y)&#123; int lca(LCA(x,y)); update(id[lca],-2); update(id[x],1); update(id[y],1);&#125;inline int Q(int x)&#123; return query(id[x],r[x]);&#125;typedef long long L;L ans(0);inline L get(int x)&#123; if(x==0) return m; if(x==1) return 1; else return 0;&#125;inline int gg()&#123; freopen("yam.in","r",stdin); freopen("yam.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); for(int i=1;i&lt;n;i++)&#123; int x(read()),y(read()); insert(x,y); insert(y,x); &#125; dfs1(1); dfs2(1,1); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); change(x,y); &#125; for(int i=2;i&lt;=n;i++)&#123; int ret(Q(i)); ans+=get(ret); &#125; printf("%d",ans);&#125;int K(gg());int main()&#123;;&#125; ps:树状数组比线段树lazy快一万倍= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树剖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tyvj 1729 文艺平衡树]]></title>
    <url>%2F2017%2F07%2F15%2F13%2F</url>
    <content type="text"><![CDATA[题目您需要写一种数据结构（可参考题目标题），来维护一个有序数列，其中需要提供以下操作：翻转一个区间，例如原有序序列是5 4 3 2 1，翻转区间是[2,4]的话，结果是5 2 3 4 1 INPUT第一行为n,m n表示初始序列有n个数，这个序列依次是(1,2……n-1,n) m表示翻转操作次数接下来m行每行两个数[l,r] 数据保证 1&lt;=l&lt;=r&lt;=n OUTPUT输出一行n个数字，表示原始序列经过m次变换后的结果 SAMPLEINPUT5 31 31 31 4 OUTPUT4 3 2 1 5 解题报告板子题，Splay，fhq-Treap什么的，我半个都不会呢= =上板子= =123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum;&#125;int n,m,top;struct node&#123; int v,key,size,mark; node *ch[2]; node(int x=0):size(1),key(rand()),mark(0),v(x)&#123; ch[0]=ch[1]=NULL; &#125; inline void revs(); inline void pushup(); inline void pushdown()&#123; if(mark)&#123; if(ch[0]) ch[0]-&gt;revs(); if(ch[1]) ch[1]-&gt;revs(); mark=0; &#125; &#125;&#125;*root,*st[100005];typedef pair&lt;node*,node*&gt;p;inline void swp(node *x,node *y)&#123; node *tmp(x); x=y; y=tmp;&#125;inline int get_size(node *x)&#123; if(x==NULL) return 0; return x-&gt;size;&#125;inline void node::revs()&#123; mark^=1; swap(ch[0],ch[1]);&#125;inline void node::pushup()&#123; size=1; size+=get_size(ch[0])+get_size(ch[1]);&#125;inline node* build()&#123; node *x,*las; for(int i=1;i&lt;=n;i++)&#123; x=new node(i); las=NULL; while(top&amp;&amp;st[top]-&gt;key&gt;x-&gt;key)&#123; st[top]-&gt;pushup(); las=st[top]; st[top--]=NULL; &#125; if(top) st[top]-&gt;ch[1]=x; x-&gt;ch[0]=las; st[++top]=x; &#125; while(top) st[top--]-&gt;pushup(); return st[1];&#125;inline node* merge(node *x,node *y)&#123; if(x==NULL) return y; if(y==NULL) return x; if(x-&gt;key&lt;y-&gt;key)&#123; x-&gt;pushdown(); x-&gt;ch[1]=merge(x-&gt;ch[1],y); x-&gt;pushup(); return x; &#125; else&#123; y-&gt;pushdown(); y-&gt;ch[0]=merge(x,y-&gt;ch[0]); y-&gt;pushup(); return y; &#125;&#125;inline p split(node *x,int k)&#123; if(!x) return p(NULL,NULL); p y; x-&gt;pushdown(); if(get_size(x-&gt;ch[0])&gt;=k)&#123; y=split(x-&gt;ch[0],k); x-&gt;ch[0]=y.second; x-&gt;pushup(); y.second=x; &#125; else&#123; y=split(x-&gt;ch[1],k-get_size(x-&gt;ch[0])-1); x-&gt;ch[1]=y.first; x-&gt;pushup(); y.first=x; &#125; return y;&#125;inline int rk(node *rt,int x)&#123; if(!rt) return 0; return x&lt;rt-&gt;v?rk(rt-&gt;ch[0],x):rk(rt-&gt;ch[1],x)+get_size(rt-&gt;ch[0])+1;&#125;inline int kth(int k)&#123; p x(split(root,k-1)),y(split(x.second,1)); node *tmp(y.first); root=merge(merge(x.first,tmp),y.second); return tmp-&gt;v;&#125;inline void insert(int x)&#123; int k(rk(root,x)); p tp(split(root,k)); node *tmp(new node(x)); root=merge(merge(tp.first,tmp),tp.second);&#125;inline void print(node *x)&#123; if(!x) return; x-&gt;pushdown(); print(x-&gt;ch[0]); printf("%d ",x-&gt;v); print(x-&gt;ch[1]);&#125;inline int gg()&#123; srand(time(NULL)); n=read(),m=read(); root=build(); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); if(x==y) continue; p tmp1(split(root,x-1)),tmp2(split(tmp1.second,y-x+1)); tmp2.first-&gt;revs(); root=merge(tmp1.first,merge(tmp2.first,tmp2.second)); &#125; print(root);&#125;int k(gg());int main()&#123;;&#125; 代码极其漂（chou）亮（lou），请慢（gan）慢（jin）欣（tui）赏（chu）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>fhq-Treap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个奇怪的大水题]]></title>
    <url>%2F2017%2F07%2F15%2F12%2F</url>
    <content type="text"><![CDATA[导引这是两道由OSU（貌似是一个我没有听说过的游戏）引申出的大水题（淼到不行啊喂），壹佰万行代码哦。 T1 OSU！题目osu 是一款群众喜闻乐见的休闲软件。我们可以把osu的规则简化与改编成以下的样子:一共有n次操作，每次操作只有成功与失败之分，成功对应1，失败对应0，n次操作对应为1个长度为n的01串。在这个串中连续的 X个1可以贡献X^3 的分数，这x个1不能被其他连续的1所包含（也就是极长的一串1，具体见样例解释）现在给出n，以及每个操作的成功率，请你输出期望分数，输出四舍五入后保留1位小数。 INPUT第一行有一个正整数n,表示操作个数。接下去n行每行有一个[0,1]之间的实数，表示每个操作的成功率。 OUTPUT只有一个实数，表示答案。答案四舍五入后保留1位小数。 SAMPLEINPUT30.50.50.5 OUTPUT6.0n&lt;=100000 样例说明（其实并不存在，只是我瞎说的而已= =）{0,0,0} 0{0,0,1} 1{0,1,0} 1{0,1,1} 2^3=8{1,0,0} 1{1,0,1} 1+1=2{1,1,0} 2^3=8{1,1,1} 3^3=27总期望=(0+1+1+8+1+2+8+27)/8=6 解题报告好水啊= =其实就是个递推，我们要求3次方，为了方便，我们可以先推出1次方和2次方，再去推3次方，我们要用到几个及其高（jian）深（dan）的高（xiao）等（xue）数（shu）学（xue）定（gong）理（shi）: (x+y)^2=x^2+2xy+y^2(x+y)^3=x^3+3(x^2)y+3x(y^2)+y^3然后就可以推了12345678910111213141516171819#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;double f[100001],s[100001],t[100001];int n;double x[100001];int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lf",&amp;x[i]); for(int i=1;i&lt;=n;i++)&#123; f[i]=(f[i-1]+1)*x[i]; s[i]=(s[i-1]+f[i-1]*2+1)*x[i]; t[i]=t[i-1]+(s[i-1]*3+f[i-1]*3+1)*x[i];// cout&lt;&lt;i&lt;&lt;' '&lt;&lt;f[i]&lt;&lt;' '&lt;&lt;s[i]&lt;&lt;' '&lt;&lt;t[i]&lt;&lt;endl; &#125; printf("%.1lf",/*f[n]+s[n]+*/t[n]);&#125; T2 Tyvj1952 Easy题目某一天WJMZBMR在打osu~~~但是他太弱了，有些地方完全靠运气:(我们来简化一下这个游戏的规则有n次点击要做，成功了就是o，失败了就是x，分数是按comb计算的，连续a个comb就有a*a分，comb就是极大的连续o。比如ooxxxxooooxxx，分数就是2×2+4×4=4+16=20。Sevenkplus闲的慌就看他打了一盘，有些地方跟运气无关要么是o要么是x，有些地方o或者x各有50%的可能性，用?号来表示。比如oo?xx就是一个可能的输入。那么WJMZBMR这场osu的期望得分是多少呢？比如oo?xx的话，?是o的话就是oooxx =&gt; 9，是x的话就是ooxxx =&gt; 4期望自然就是(4+9)/2 =6.5了 INPUT第一行一个整数n，表示点击的个数接下来一个字符串，每个字符都是ox？中的一个 OUTPUT一行一个浮点数表示答案四舍五入到小数点后4位如果害怕精度跪建议用long double或者extended SAMPLEINPUT4???? OUTPUT4.1250n&lt;=300000osu很好玩的哦WJMZBMR技术还行(雾),x基本上很少呢 解题报告话说最后那句话真是interesting呢= =其实跟上面那道题一样，只是把概率给出的方式变得委（zhi）婉（zhang）了显然，o的概率为1，x的概率为0，？的概率为0.5然后？然后就变成了上面那道题的二次方版，但要注意递推的时候的某些细节12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;double f[300001],s[300001];int n;char op[300005];double x;int main()&#123; scanf("%d%s",&amp;n,op+1); for(int i=1;i&lt;=n;i++)&#123; if(op[i]=='o') x=1.0; if(op[i]=='?') x=0.5; if(op[i]=='x') x=0.0; f[i]=(f[i-1]+1)*x; s[i]=s[i-1]+(f[i-1]*2+1)*x;//cout&lt;&lt;i&lt;&lt;' '&lt;&lt;f[i]&lt;&lt;' '&lt;&lt;s[i]&lt;&lt;endl; &#125; printf("%.4f",s[n]);&#125; 话说OSU到底是什么啊= =还有，我最近好像一直在做水题啊，这样下去不就只能在欢声笑语中打出GG了么= =（水题骑脸怎么输）]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017-7-9至2017-7-15小集训总结]]></title>
    <url>%2F2017%2F07%2F15%2F11%2F</url>
    <content type="text"><![CDATA[关于考试说实话，没想到能考成这个样子，总共不到30个人，D1考试rk4，到D4rk二十几，真是interesting(annoying)，明明有好多题都基本上是正解却还不如暴力分多啊喂= =明明打上了矩阵，结果发现矩阵建成了一坨奇奇怪怪的东西，明明能现场推出来tarjan（不要问我为什么要现场推= =），却生生要用它打dfs，明明最暴力都能过的题（谁能告诉我为啥树剖T的题，一个一个爬就能过），明明树剖都打完了，线段树竟然不会打了。。。 这事情真的难办啊。。。 关于刷题这几天的题也是很神奇的，从网上找的所有正解都过不去，一个啥都不是的暴力竟然踩过了众标程= =一道国家集训队的题目，看到标题吓死人，10分钟后笑死人= =从来没有去看过某同学的代码，连思路都没有问他，然后被OJ报了代码相似= =一道tarjan调了两个小时，发现手抽打错变量，身败名裂= =COGS上的榜被同学各种刷，然而并不会刷到我，因为。。。我可是rk1hhh 关于生活这几天真的是奥（qi）妙（qi）重（guai）重（guai）莫名摔了一下，刚跑完操，要去机房，我刚要加速跑，然后。。。然后我的同桌在前面蹲下系鞋带。。。后来在医务室的良（hei）心（xin）大（yao）夫（dian）的精（bao）心（li）照（jie）料（jue）下，我只能去和（de）平（guo）医（gu）院（ke）接受治疗了。然后。。。平常5分钟的路，20分钟我能走完算我赢啊喂= = 其实还是喜欢集训的，可以整天待在机房，刷刷题，写写博客，受了伤有同学帮我把早饭带到机房，虽然有时还是要靠自己单脚跳着上楼，出了汗流到伤口里疼得要死，但也比学高考课什么的好一万倍啊。 可能就是这样吧，想抓住的东西，越挣扎，越难以抓住，就像手中的沙，终会流走吧。 最后背首诗吧苟利。。。啊，不好意思背错了 长太息以掩涕兮哀民生之多艰余虽好修姱以鞿羁兮謇朝谇而夕替既替余以蕙纕兮又申之以揽茝亦余心之所善兮虽九死其犹未悔怨灵修之浩荡兮终不察夫民心众女嫉余之蛾眉兮谣诼谓余以善淫 不会背了= =总之就是这样了，赶紧放假，等着下次集训呢]]></content>
      <categories>
        <category>集训总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队2011]单选错位]]></title>
    <url>%2F2017%2F07%2F15%2F10%2F</url>
    <content type="text"><![CDATA[题目gx和lc去参加noip初赛，其中有一种题型叫单项选择题，顾名思义，只有一个选项是正确答案。试卷上共有n道单选题，第i道单选题有ai个选项，这ai个选项编号是1,2,3,…,ai，每个选项成为正确答案的概率都是相等的。lc采取的策略是每道题目随机写上1-ai的某个数作为答案选项，他用不了多少时间就能期望做对sigma(1/ai)道题目。gx则是认认真真地做完了这n道题目，可是等他做完的时候时间也所剩无几了，于是他匆忙地把答案抄到答题纸上，没想到抄错位了：第i道题目的答案抄到了答题纸上的第i+1道题目的位置上，特别地，第n道题目的答案抄到了第1道题目的位置上。现在gx已经走出考场没法改了，不过他还是想知道自己期望能做对几道题目，这样他就知道会不会被lc鄙视了。我们假设gx没有做错任何题目，只是答案抄错位置了。 INPUTn很大，为了避免读入耗时太多，输入文件只有5个整数参数n, A, B, C, a1，由上交的程序产生数列a。下面给出pascal/C/C++的读入语句和产生序列的语句（默认从标准输入读入）：// for pascalreadln(n,A,B,C,q[1]);for i:=2 to n doq[i] := (int64(q[i-1]) * A + B) mod 100000001;for i:=1 to n doq[i] := q[i] mod C + 1; // for C/C++scanf(“%d%d%d%d%d”,&amp;n,&amp;A,&amp;B,&amp;C,a+1);for (int i=2;i&lt;=n;i++)a[i] = ((long long)a[i-1] * A + B) % 100000001;for (int i=1;i&lt;=n;i++)a[i] = a[i] % C + 1;选手可以通过以上的程序语句得到n和数列a（a的元素类型是32位整数），n和a的含义见题目描述。 OUTPUT输出一个实数，表示gx期望做对的题目个数，保留三位小数。 SAMPLEINPUT3 2 0 4 1 OUTPUT1.167 样例说明a[]={2,3,1}正确答案{1,1,1}gx的答案{1,1,1}做对题目 3出现概率 1/6 正确答案{1,2,1}gx的答案{1,1,2}做对题目 1出现概率 1/6 正确答案{1,3,1}gx的答案{1,1,3}做对题目 1出现概率 1/6 正确答案{2,1,1}gx的答案{1,2,1}做对题目 1出现概率 1/6 正确答案{2,2,1}gx的答案{1,2,2}做对题目 2出现概率 1/6 正确答案{2,3,1}gx的答案{1,2,3}做对题目 0出现概率 1/6共有6种情况，每种情况出现的概率是1/6，gx期望做对(3+1+1+1+1+0)/6 = 7/6题。（相比之下，lc随机就能期望做对11/6题） 数据规模对于30%的数据 n≤10, C≤10对于80%的数据 n≤10000, C≤10对于90%的数据 n≤500000, C≤100000000对于100%的数据 2≤n≤10000000, 0≤A,B,C,a1≤100000000 解题报告说实话，一眼看到 国家集训队我好方啊= =能不能骗个20分什么的= =但当我10分钟后AC顺手上了个COGS rk1时= = 不扯了不扯了 很简单的概率与期望，我们考虑: 当a[i]&lt;=a[i+1]时，显然第i题的正确答案一定被第i+1题可能出现的正确答案所包含，所以概率为1/a[i+1]，而对答案的贡献又为1，所以期望也为1。 反之，第i题的正确答案不一定在第i+1题的答案集合中，在的概率为a[i+1]/a[i]，而如果在该集合中，又为正确答案的概率为1/a[i+1]，两数相乘，得到总概率为1/a[i]，则期望为1/a[i]。 扯了这么多，其实就是个两数max求倒数= = 国家集训队竟有如此水题= = 天啊= = 12345678910111213141516171819202122232425262728293031323334353637 #include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;int n,A,B,C;int a[10000001];double ans(0);inline int gg()&#123; freopen("nt2011_exp.in","r",stdin); freopen("nt2011_exp.out","w",stdout); n=read(),A=read(),B=read(),C=read(),a[1]=read(); for(int i=2;i&lt;=n;i++) a[i]=((long long)a[i-1]*A+B)%100000001; for(int i=1;i&lt;=n;i++) a[i]=a[i]%C+1; for(int i=1;i&lt;n;i++)&#123; if(a[i]&lt;=a[i+1]) ans+=1.0/(double)a[i+1]; else ans+=1.0/(double)a[i]; &#125; if(a[n]&lt;a[1]) ans+=1.0/(double)a[1]; else ans+=1.0/(double)a[n]; printf("%.3f",ans); return 0;&#125;int k(gg());int main()&#123;;&#125; 这么水的题= =真是少见= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Hnoi2013]游走]]></title>
    <url>%2F2017%2F07%2F15%2F9%2F</url>
    <content type="text"><![CDATA[题目一个无向连通图，顶点从1编号到N，边从1编号到M。 小Z在该图上进行随机游走，初始时小Z在1号顶点，每一步小Z以相等的概率随机选 择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当小Z 到达N号顶点时游走结束，总分为所有获得的分数之和。现在，请你对这M条边进行编号，使得小Z获得的总分的期望值最小。 INPUT第一行是正整数N和M，分别表示该图的顶点数 和边数，接下来M行每行是整数u，v(1≤u,v≤N)，表示顶点u与顶点v之间存在一条边。 输入保证30%的数据满足N≤10，100%的数据满足2≤N≤500且是一个无向简单连通图。 OUTPUT仅包含一个实数，表示最小的期望值，保留3位小数。 SAMPLEINPUT3 32 31 21 3 OUTPUT3.333 解题报告这东西显然是个概率与期望（题目写的那么清楚啊喂），好吧，是一个很裸的概率与期望。题目要求总分最小，且编号从1到m，那么显然，我们需要求一下每条边被经过的期望，期望越大，编号越小。首先自然能删除终点的所有出边（终点是不能出来的），然后，对于每一条边，设两端端点为u，v，我们可以从u走到v，也可以从v走到u，从u走到v的期望次数等于 经过点u的次数/u的度问题自然就转化成求每个点的期望经过次数，对于起点来说，一开始一定会经过一次，在之后也可能被经过。 f[1]=1+sigma(f[j]/degree[j],j和1有边相连)f[i]=sigma(f[j]/degree[j],i与j有边相连)我们得到了n变量n方程的方程组，然后高斯消元乱抡= =稍微处理下就可以得到经过每个点的期望，那么每条边的期望即为两端点期望之和（注意：对终点一定要特殊处理啊啊啊），对每条边按期望排序，随便一乘，一加，就可以AC了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); for(;ch&lt;'0'||ch&gt;'9';ch=getchar()); for(;ch&gt;='0'&amp;&amp;ch&lt;='9';sum=sum*10+(ch^48),ch=getchar()); return sum;&#125;struct edge&#123; int s,e,n;&#125;ed[250001];int pre[501],tot;inline void insert(int s,int e)&#123; ed[++tot].s=s; ed[tot].e=e; ed[tot].n=pre[s]; pre[s]=tot;&#125;int du[501];int n,m;double a[501][501],b[501],ans[501];inline double jdz(double x)&#123; return x&gt;=0?x:-x;&#125;inline void swp(double &amp;a,double &amp;b)&#123; double c(a); a=b; b=c;&#125;inline void gauss()&#123; int num,cnt(1); for(int i=1;i&lt;n;i++,cnt++)&#123; num=i; for(int j=i+1;j&lt;=n;j++) if(jdz(a[num][i])&lt;jdz(a[j][i])) num=j; if(num!=i)&#123; for(int j=1;j&lt;=n;j++) swp(a[num][j],a[cnt][j]); swp(b[num],b[cnt]); &#125; if(!a[cnt][i])&#123; cnt--; continue; &#125; for(int j=cnt+1;j&lt;=n;j++)&#123; double t(a[j][i]/a[cnt][i]); for(int k=i;k&lt;=n;k++) a[j][k]-=t*a[i][k]; b[j]-=t*b[i]; &#125; &#125; for(int i=n;i&gt;0;i--)&#123; for(int j=n;j&gt;i;j--) b[i]-=a[i][j]*ans[j]; ans[i]=b[i]/a[i][i]; &#125;&#125;double f[250001];bool g[501][501];inline int gg()&#123;// freopen("walk.in","r",stdin);// freopen("walk.out","w",stdout); n=read(),m=read(); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); insert(x,y); g[x][y]=g[y][x]=1; du[x]++,du[y]++; &#125; du[n]=0; for(int i=1;i&lt;=n;i++)&#123; if(i==1) b[i]=1; else b[i]=0; for(int j=1;j&lt;=n;j++)&#123; if(i==j)&#123; a[i][j]=1; continue; &#125; if(j==n)&#123; a[i][j]=0; continue; &#125; if(g[i][j]) a[i][j]=-1.0/(double)du[j]; &#125; &#125; gauss(); for(int i=1;i&lt;n;i++) ans[i]/=du[i]; ans[n]=0; for(int i=1;i&lt;=tot;i++)&#123; int s(ed[i].s),e(ed[i].e); f[i]=ans[s]+ans[e]; &#125; int cnt(tot); sort(f+1,f+tot+1); double an(0); for(int i=1;i&lt;=tot;i++) an+=i*f[cnt--]; printf("%.3lf",an); return 0;&#125;int k(gg());int main()&#123;;&#125; ps:COGS rk1代码奉上，虽然榜貌似被两个神奇的（hhh）刷成（hhh）了，但是还是没有什么影响。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Usaco2015 Jan]Grass Cownoisseur]]></title>
    <url>%2F2017%2F07%2F14%2F8%2F</url>
    <content type="text"><![CDATA[题目大意 给一个有向图，然后选一条路径起点终点都为1的路径出来，有一次机会可以沿某条边逆方向走，问最多有多少个点可以被经过？ （一个点在路径中无论出现多少正整数次对答案的贡献均为1） INPUT The first line of input contains N and M, giving the number of fields and the number of one-way paths (1 &lt;= N, M &lt;= 100,000). The following M lines each describe a one-way cow path. Each line contains two distinct field numbers X and Y, corresponding to a cow path from X to Y. The same cow path will never appear more than once. N个点，M条有向边，无重边 OUTPUT A single line indicating the maximum number of distinct fields Bessiecan visit along a route starting and ending at field 1, given that she canfollow at most one path along this route in the wrong direction. SAMPLEINPUT7 101 23 12 52 43 73 53 66 57 24 7 OUTPUT6 解题报告这道题考试的时候，一看就知道是tarjan，然后就真的傻傻的打了个tarjan+dfs，就A了一个点= =正解：tarjan缩点，因为可以逆转一条边，而同一强连通分量里的边逆转是没啥用的，所以我们可以枚举缩点后的边。首先，跑2遍SPFA，一遍缩点后的正边，一遍反边，处理出正反两个最大的经过权值（每点权值为缩点后强连通分量的点数）。剩下的就很简单了，思考当一条有向边反过来时，它反边的起点走的是正向的最大权值，而终点则走的是反向的最大权值，那么我们枚举每一条边，两权相加求max即为答案。注意：特判，两边SPFA若有一遍没有联通这条边对应的强连通分量，这个点就不能跑。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum;&#125;struct edge&#123; int s,e,n;&#125;k[100001],a[100001],b[100001];int pre[100001],tot;inline void insert(int s,int e)&#123; k[++tot].s=s; k[tot].e=e; k[tot].n=pre[s]; pre[s]=tot;&#125;int low[100001],dfn[100001],stack[100001],bl[100001],size[100001];int head,cnt,qlt;bool vis[100001];inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;inline void tarjan(int u)&#123; low[u]=dfn[u]=++cnt; vis[u]=1; stack[++head]=u; for(int i=pre[u];i!=-1;i=k[i].n)&#123; int e(k[i].e); if(!dfn[e])&#123; tarjan(e); low[u]=my_min(low[u],low[e]); &#125; else if(vis[e]) low[u]=my_min(low[u],dfn[e]); &#125; if(low[u]==dfn[u])&#123; int tmp; qlt++; while(1)&#123; tmp=stack[head--]; bl[tmp]=qlt; vis[tmp]=0; if(tmp==u) break; &#125; &#125;&#125;int adj[100001],num;inline void add(int s,int e)&#123; a[++num].s=s; a[num].e=e; a[num].n=adj[s]; adj[s]=num;&#125;queue&lt;int&gt;q;int fz[100001];inline void spfa1(int x)&#123; memset(vis,0,sizeof(vis)); memset(fz,0,sizeof(fz)); q.push(x); fz[x]=size[x]; vis[x]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=adj[k];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(fz[e]&lt;fz[k]+size[e])&#123; fz[e]=fz[k]+size[e]; if(!vis[e])&#123; q.push(e); vis[e]=1; &#125; &#125; &#125; vis[k]=0; &#125;&#125;int hhh,nxt[100001];inline void init(int s,int e)&#123; b[++hhh].s=s; b[hhh].e=e; b[hhh].n=nxt[s]; nxt[s]=hhh;&#125;int ff[100001];inline void spfa2(int x)&#123; memset(vis,0,sizeof(vis)); memset(ff,0,sizeof(ff)); q.push(x); ff[x]=size[x]; vis[x]=1; while(!q.empty())&#123; int k(q.front()); q.pop(); for(int i=nxt[k];i!=-1;i=b[i].n)&#123; int e(b[i].e); if(ff[e]&lt;ff[k]+size[e])&#123; ff[e]=ff[k]+size[e]; if(!vis[e])&#123; q.push(e); vis[e]=1; &#125; &#125; &#125; vis[k]=0; &#125;&#125;inline int find(int x)&#123; int s(a[x].e),e(a[x].s); if(!fz[s]||!ff[e]) return 0; return fz[s]+ff[e]-size[bl[1]];&#125;int n,m;int main()&#123; memset(pre,-1,sizeof(pre)); memset(adj,-1,sizeof(adj)); memset(nxt,-1,sizeof(nxt)); n=read(),m=read(); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); insert(x,y); &#125; for(int i=1;i&lt;=n;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) size[bl[i]]++; for(int i=1;i&lt;=tot;i++)&#123; int s(k[i].s),e(k[i].e); if(bl[s]!=bl[e]) add(bl[s],bl[e]),init(bl[e],bl[s]); &#125; spfa1(bl[1]); spfa2(bl[1]); int ans(0); for(int i=1;i&lt;=num;i++) ans=my_max(ans,find(i)); printf("%d\n",ans);&#125; ps:调了我两个小时，最后发现重新建边的时候我用的原来点的编号，没有用缩完点后的编号，然后就听取蛙声一片了= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tyvj 1518 CPU监控]]></title>
    <url>%2F2017%2F07%2F12%2F7%2F</url>
    <content type="text"><![CDATA[题目Bob需要一个程序来监视CPU使用率。这是一个很繁琐的过程，为了让问题更加简单，Bob会慢慢列出今天会在用计算机时做什么事。Bob会干很多事，除了跑暴力程序看视频之外，还会做出去玩玩和用鼠标乱点之类的事，甚至会一脚踢掉电源……这些事有的会让做这件事的这段时间内CPU使用率增加或减少一个值；有的事还会直接让CPU使用率变为一个值。当然Bob会询问：在之前给出的事件影响下，CPU在某段时间内，使用率最高是多少。有时候Bob还会好奇地询问，在某段时间内CPU曾经的最高使用率是多少。为了使计算精确，使用率不用百分比而用一个整数表示。不保证Bob的事件列表出了莫名的问题，使得使用率为负……………… INPUT第一行一个正整数T，表示Bob需要监视CPU的总时间。然后第二行给出T个数表示在你的监视程序执行之前，Bob干的事让CPU在这段时间内每个时刻的使用率达已经达到了多少。第三行给出一个数E，表示Bob需要做的事和询问的总数。接下来E行每行表示给出一个询问或者列出一条事件：Q X Y:询问从X到Y这段时间内CPU最高使用率A X Y:询问从X到Y这段时间内之前列出的事件使CPU达到过的最高使用率P X Y Z:列出一个事件这个事件使得从X到Y这段时间内CPU使用率增加ZC X Y Z:列出一个事件这个事件使得从X到Y这段时间内CPU使用率变为Z时间的单位为秒，使用率没有单位。X和Y均为正整数（X&lt;=Y），Z为一个整数。从X到Y这段时间包含第X秒和第Y秒。保证必要运算在有符号32位整数以内。 OUTPUT对于每个询问，输出一行一个整数回答。 SAMPLEINPUT10-62 -83 -9 -70 79 -78 -31 40 -18 -520A 2 7A 4 4Q 4 4P 2 2 -74P 7 9 -71P 7 10 -8A 10 10A 5 9C 1 8 10Q 6 6Q 8 10A 1 7P 9 9 96A 5 5P 8 10 -53P 6 6 5A 10 10A 4 4Q 1 5P 4 9 -69 OUTPUT79-70-70-57910107979-51010 解题报告这道极其简（e）单（xin），真的是一道裸（zhi）的（zhang）线段树。首先，我们需要维护各种奇奇怪怪的域，当前和，当前最大值，历史和，历史最大值，而历史值又不包括当前值，这就导致了lazy操作的pushdown极其好（nan）写。没有什么好多说的，直接看这个极其漂（chou）亮（lou）的代码= =123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;const int inf=1&lt;&lt;31;inline int read()&#123; int sum(0),f(1); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum*f;&#125;int n,m;int v[100001];int padd[400001],pset[400001],pmx[400001];int nadd[400001],nset[400001],nmx[400001];inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;inline void pushup(int i)&#123; int l(i&lt;&lt;1),r(l|1); pmx[i]=my_max(pmx[l],pmx[r]); nmx[i]=my_max(nmx[l],nmx[r]);&#125;inline void pushdown(int rt)&#123; int ch(rt&lt;&lt;1); for(int i=0;i&lt;=1;i++)&#123; int nowch(ch+i); pmx[nowch]=my_max(pmx[nowch],my_max(padd[rt]+nmx[nowch],pset[rt])); if(nset[rt]==inf)&#123; nmx[nowch]+=nadd[rt]; if(nset[nowch]==inf)&#123; padd[nowch]=my_max(padd[nowch],nadd[nowch]+padd[rt]); nadd[nowch]+=nadd[rt]; &#125; else&#123; pset[nowch]=my_max(pset[nowch],nset[nowch]+padd[rt]); nset[nowch]=nmx[nowch]; &#125; &#125; else&#123; if(nset[nowch]==inf)&#123; padd[nowch]=my_max(padd[nowch],nadd[nowch]+padd[rt]); nadd[nowch]+=padd[rt]; &#125; else pset[nowch]=my_max(pset[nowch],nmx[nowch]+padd[rt]); nmx[nowch]=nset[rt]; nset[nowch]=nset[rt]; pset[nowch]=my_max(pset[rt],pset[nowch]); &#125; &#125; nadd[rt]=0; padd[rt]=0; nset[rt]=inf; pset[rt]=inf;&#125;inline void build(int l,int r,int i)&#123; padd[i]=0; pset[i]=inf; nadd[i]=0; nset[i]=inf; if(l==r)&#123; pmx[i]=v[l]; nmx[i]=v[l]; return; &#125; int lc(i&lt;&lt;1),rc(lc|1),mid((l+r)&gt;&gt;1); build(l,mid,lc); build(mid+1,r,rc); pushup(i);&#125;inline void update_set(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; nset[i]=c; nmx[i]=c; pset[i]=my_max(pset[i],nset[i]); pmx[i]=my_max(pmx[i],nmx[i]); return; &#125; pushdown(i); int lc(i&lt;&lt;1),rc(lc|1),mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update_set(ll,rr,c,l,mid,lc); if(rr&gt;mid) update_set(ll,rr,c,mid+1,r,rc); pushup(i);&#125;inline void update_add(int ll,int rr,int c,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr)&#123; nmx[i]+=c; pmx[i]=my_max(pmx[i],nmx[i]); if(nset[i]==inf)&#123; nadd[i]+=c; padd[i]=my_max(padd[i],nadd[i]); &#125; else&#123; nset[i]=nmx[i]; pset[i]=my_max(pset[i],nset[i]); &#125; return; &#125; pushdown(i); int lc(i&lt;&lt;1),rc(lc|1),mid((l+r)&gt;&gt;1); if(ll&lt;=mid) update_add(ll,rr,c,l,mid,lc); if(rr&gt;mid) update_add(ll,rr,c,mid+1,r,rc); pushup(i);&#125;inline int query_p(int ll,int rr,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return pmx[i]; pushdown(i); int lc(i&lt;&lt;1),rc(lc|1),mid((l+r)&gt;&gt;1); int ret(inf); if(ll&lt;=mid) ret=my_max(ret,query_p(ll,rr,l,mid,lc)); if(rr&gt;mid) ret=my_max(ret,query_p(ll,rr,mid+1,r,rc)); return ret;&#125;inline int query_n(int ll,int rr,int l,int r,int i)&#123; if(ll&lt;=l&amp;&amp;r&lt;=rr) return nmx[i]; pushdown(i); int lc(i&lt;&lt;1),rc(lc|1),mid((l+r)&gt;&gt;1); int ret(inf); if(ll&lt;=mid) ret=my_max(ret,query_n(ll,rr,l,mid,lc)); if(rr&gt;mid) ret=my_max(ret,query_n(ll,rr,mid+1,r,rc)); return ret;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) v[i]=read(); /*for(int i=1;i&lt;=n;i++) cout&lt;&lt;v[i]&lt;&lt;' ';*/ build(1,n,1); m=read(); char op[2]; while(m--)&#123; scanf("%s",op); if(op[0]=='Q')&#123; int x(read()),y(read()); printf("%d\n",query_n(x,y,1,n,1)); continue; &#125; if(op[0]=='A')&#123; int x(read()),y(read()); printf("%d\n",query_p(x,y,1,n,1)); continue; &#125; if(op[0]=='P')&#123; int x(read()),y(read()),z(read()); update_add(x,y,z,1,n,1); continue; &#125; if(op[0]=='C')&#123; int x(read()),y(read()),z(read()); update_set(x,y,z,1,n,1); continue; &#125; &#125;//while(1);&#125; ps:本以为可以写到200行，后来pushdown强行压了一半，然后各种压行，形成了如此漂（chou）亮（lou）的代码风格= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种奇怪的韩信问题]]></title>
    <url>%2F2017%2F07%2F12%2F6%2F</url>
    <content type="text"><![CDATA[这是两道奇怪的韩信问题韩信点兵&amp;丧心病狂的韩信大点兵 ———————————————T1[COGS1786]韩信点兵题目韩信是中国军事思想“谋战”派代表人物，被后人奉为“兵仙”、“战神”。“王侯将相”韩信一人全任。“国士无双”、“功高无二，略不世出”是楚汉之时人们对其的评价。作为统帅，他率军出陈仓、定三秦、擒魏、破代、灭赵、降燕、伐齐，直至垓下全歼楚军，无一败绩，天下莫敢与之相争。 相传，韩信带兵打仗时，从不直接清点军队人数。有一次，韩信带1500名兵士打仗，战死四五百人。站3人一排，多出2人；站5人一排，多出4人；站7人一排，多出6人。韩信马上说出人数：1049。 这次，刘邦派韩信带兵N人攻打一座重兵驻扎的城市。城市占领了，可汉军也是伤亡惨重。韩信需要知道汉军至少损失了多少兵力，好向刘邦汇报。 已知韩信发出了M次命令，对于第i次命令，他选择一个素数Pi，要求士兵每Pi人站一排，此时最后一排剩下了ai人。你的任务是帮助韩信求出这种情况下汉军损失兵力的最小值。当然，由于士兵们都很疲惫，他们有可能站错队伍导致韩信得到的数据有误。 INPUT第一行两个正整数N,M，分别代表最初的军队人数和韩信的询问次数。接下来有M行，每行两个非负整数Pi，ai，代表韩信选择的素数和此时剩下的人数。输入保证每个素数各不相同。 OUTPUT输出一行，一个整数。若有解，输出最小损失人数。若无解，输出-1. SAMPLEINPUT1500 33 25 47 6 OUTPUT31 解题报告CRT裸题CRT：中国剩余定理设正整数m1,m2,…,mk两两互素，则同余方程组 x≡a1 (mod m1)x≡a2 (mod m2)x≡a3 (mod m3). . . . . .x≡ak (mod mk)有整数解，并且在模M=m1×m2×…×mk下的解是唯一的，解为 x≡(a1×M1×ny(M1)+…+ak×Mk×ny(Mk))mod M其中Mi=M/mi，而ny(Mi)为Mi模mi的逆元代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long L;L n;int m;L a[11],mod[11];L M(1),ans(0);inline void extend_gcd(L a,L b,L &amp;x,L &amp;y)&#123; if(b==0)&#123; x=1; y=0; return; &#125; extend_gcd(b,a%b,x,y); L tmp(x); x=y; y=tmp-(a/b)*y;&#125;inline L CRT(L a[],L m[],int n)&#123; for(int i=1;i&lt;=n;i++) M*=m[i]; for(int i=1;i&lt;=n;i++)&#123; L x,y; L Mi(M/m[i]); extend_gcd(Mi,m[i],x,y); ans=(ans+M+Mi*x*a[i])%M; &#125; //if(ans&lt;0) // ans+=M; return ans;&#125;inline int gg()&#123; freopen("HanXin.in","r",stdin); freopen("HanXin.out","w",stdout); scanf("%lld%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%lld%lld",&amp;mod[i],&amp;a[i]); L ans(CRT(a,mod,m)); if(ans&gt;n)&#123; puts("-1"); return 0; &#125; while(ans&lt;n) ans+=M; ans-=M; printf("%lld",n-ans);&#125;int k(gg());int main()&#123;;&#125; 需要注意的是，要求的是最小损失人数，稍微处理一下结果即可 ———————————————T2[COGS2160]丧心病狂的韩信大点兵题目懒得粘了，上链接= =传送门这道题显然不能用普通的CRT做，因为它们不互质此时我们就要采用两两合并的思想，假设要合并如下两个方程 x=a1+m1x1x=a2+m2x2那么得到 a1+m1x1=a2+m2x2 ☞ m1x1+m2x2=a2-a1再利用扩展欧几里得解出x1的最小整数解，再代入 x=a1+m1x1得到x后，合并为一个方程的结果为 y≡x(mod lcm(m1,m2))这样一直合并下去，最终可以求得解代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long L;int m;L a[21],mod[21];inline L gcd(L a,L b)&#123; return a%b?gcd(b,a%b):b;&#125;inline L ext_gcd(L a,L b,L &amp;x,L &amp;y)&#123; if(b==0)&#123; x=1; y=0; return a; &#125; L gcd(ext_gcd(b,a%b,x,y)); L tmp(x); x=y; y=tmp-(a/b)*y; return gcd;&#125;inline L ny(L a,L b)&#123; L x,y; L gcd(ext_gcd(a,b,x,y)); if(gcd!=1) return -1; return (x%b+b)%b;&#125;inline bool merge(L a1,L m1,L a2,L m2,L &amp;a3,L &amp;m3)&#123; L d(gcd(m1,m2)); L c=a2-a1; if(c%d) return false; c=(c%m2+m2)%m2; m1/=d; m2/=d; c/=d; c*=ny(m1,m2); c%=m2; c*=m1*d; c+=a1; m3=m1*m2*d; a3=(c%m3+m3)%m3; return true;&#125;L CRT(L a[],L m[],int n)&#123; L a1(a[1]),m1(m[1]); for(int i=2;i&lt;=n;i++)&#123; L a2(a[i]),m2(m[i]),a3,m3; if(!merge(a1,m1,a2,m2,a3,m3)) return -1; a1=a3; m1=m3; &#125; return (a1%m1+m1)%m1;&#125;inline int gg()&#123; freopen("weakhanxin.in","r",stdin); freopen("weakhanxin.out","w",stdout); scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++) scanf("%lld%lld",&amp;mod[i],&amp;a[i]); printf("%lld",CRT(a,mod,m));&#125;int k(gg());int main()&#123;;&#125; ps:这份代码是目前COGS上rk1的代码，在各种0.002s中出现一个0.000s，让我这个鶸鷄感觉有些方= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学 CRT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HNOI2008]GT考试]]></title>
    <url>%2F2017%2F07%2F12%2F5%2F</url>
    <content type="text"><![CDATA[题目阿申准备报名参加GT考试，准考证号为N位数X1X2….Xn(0&lt;=Xi&lt;=9),他不希望准考证号上出现不吉利的数字。他的不吉利数学A1A2…Am(0&lt;=Ai&lt;=9)有M位，不出现是指X1X2…Xn中没有恰好一段等于A1A2…Am. A1和X1可以为0 INPUT第一行输入N,M,K.接下来一行输入M位的数。 N&lt;=10^9,M&lt;=20,K&lt;=1000 OUTPUT阿申想知道不出现不吉利数字的号码有多少种，输出模K取余的结果. SAMPLEINPUT4 3 100111 OUTPUT81 解题报告这道题一开始真心没有什么思路，后来我跟两个dalao一起商（luan）谈（gao）了一个来小时，终于搞了出来= = 首先，我们我们考虑两个串（从短到长） 第一个串为不断增加的准考证号，第二个串为不吉利的号码，第一个串的后缀与第二个串的前缀为重复部分，那么我们很容易得出递推关系 先扯出来，考虑两个集合，一个集合为不吉利的号码，一个集合为吉利的号码。我们只考虑后缀（正确性显然，因为长度长的串一定是由长度短的串递推过来的，所以如果前面有不吉利串，一定被前面的串卡掉了），当后缀包含了m个不吉利串，该串一定是不吉利的。那么，后缀包含0~m-1个不吉利串的前缀的串一定是吉利的。所以，我们把求不吉利的串 转化为 求 后缀包含不吉利串0~m-1 的 串 的 方案数 然而与字符串有啥关系？ 考虑这样一个不吉利串 123124 当你的后缀带了2时，你怎么知道你的后几位是12还是12312？所以，加一位不吉利数不代表直接在后面加了一位。 那么，问题来了，如何表示这些奇（chun）奇（de）怪（bu）怪（xing）的转移？考虑一个递推矩阵，设dp[i][j]为第i个号码匹（zhuan）配（yi）到第j个不吉利数字的方案数，设a[k][i]为k位后加一个数转移到j的方案数，我们可以轻易的得出递推关系：dp[i][j]=∑dp[i-1][k]*a[k][j]用KMP构造初始矩阵，矩阵快速幂得到递推结果。 为什么是矩阵快速幂？这个问题很简单。我们知道，矩阵乘是这样写的：12345678910martrix tmp;for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++)&#123; tmp.data[i][j]=0; for(int k=0;k&lt;n;k++)&#123; tmp.data[i][j]+=(a.data[i][k]*b.data[k][j]); tmp.data[i][j]%=mod; &#125; &#125;return tmp; 那么问题就简单起来了，考虑一个3*3的初始矩阵，第i行，第j列表示从第i位加一个数字转移到第j为数字的方案数，那么以该矩阵的平方的第一行第一列的数为例，（设初始矩阵为a，该矩阵为x）：x[1][1]=a[1][1]×a[1][1]+a[1][2]×a[2][1]+a[1][3]×a[3][1];因为是平方得到的矩阵，所以代表了转移两步的状态，我们知道，x[1][1]代表了从第一位经两步转移到第一位的方案数，由加法原理可知：1-&gt;1(经两步)=(1-&gt;1-&gt;1)+(1-&gt;2-&gt;1)+(1-&gt;3-&gt;1)而又由乘法原理可知：1-&gt;2-&gt;1=(1-&gt;2)×(2-&gt;1)那么正确性就很显然了，由矩阵快速幂的递推关系可知，最终结果即为第一行的数的和至于KMP，把10个数字扔进去乱搞就是了= =记得要模k= =12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int n,m,mod;char s[25];int kp[25];inline void get_kp()&#123; kp[0]=0; kp[1]=0; int k(0); for(int i=2;i&lt;=m;i++)&#123; while(k&amp;&amp;s[k]!=s[i-1]) k=kp[k]; if(s[k]==s[i-1]) k++; kp[i]=k; &#125;&#125;struct node&#123; int data[25][25]; node()&#123; memset(data,0,sizeof(data)); &#125; node operator*(node &amp;a)&#123; node tmp; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;m;j++)&#123; tmp.data[i][j]=0; for(int k=0;k&lt;m;k++)&#123; tmp.data[i][j]+=(data[i][k]*a.data[k][j]); tmp.data[i][j]%=mod; &#125; &#125; return tmp; &#125; node operator*=(node &amp;a)&#123; *this=*this*a; return *this; &#125;&#125;a,sing;ostream&amp; operator&lt;&lt;(ostream &amp;out,node &amp;a)&#123; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;m;j++) out&lt;&lt;a.data[i][j]&lt;&lt;' '; out&lt;&lt;endl; &#125; return out;&#125;int main()&#123; scanf("%d%d%d%s",&amp;n,&amp;m,&amp;mod,s); get_kp(); for(int i=0;i&lt;m;i++) for(int j=0;j&lt;=9;j++)&#123; int k(i); while(k&amp;&amp;(j+'0')!=s[k]) k=kp[k]; if(j+'0'==s[k]) k++; if(k!=m)&#123; a.data[i][k]++; a.data[i][k]%=mod;//cout&lt;&lt;'*'; &#125; &#125;//cout&lt;&lt;a&lt;&lt;endl; /*for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;m;j++) cout&lt;&lt;a[i][j]&lt;&lt;' '; cout&lt;&lt;'\n'; &#125;*/ for(int i=0;i&lt;m;i++) sing.data[i][i]=1; int tmp(n); while(tmp)&#123; if(tmp&amp;1) sing*=a; a*=a; //cout&lt;&lt;tmp&lt;&lt;endl; //cout&lt;&lt;a&lt;&lt;endl&lt;&lt;sing&lt;&lt;endl; tmp&gt;&gt;=1; &#125; int ans(0); for(int i=0;i&lt;m;i++)&#123; ans=(ans+sing.data[0][i])%mod; //cout&lt;&lt;ans&lt;&lt;endl; &#125; cout&lt;&lt;ans; //while(1);&#125; ps：2017-6-14 晚 讲题用题解 pss：调矩阵快调死了= =，最后发现初始矩阵求错了= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串 矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Tyvj 1728]普通平衡树]]></title>
    <url>%2F2017%2F07%2F12%2F4%2F</url>
    <content type="text"><![CDATA[题目您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作： 插入x数 删除x数(若有多个相同的数，因只删除一个) 查询x数的排名(若有多个相同的数，因输出最小的排名) 查询排名为x的数 求x的前驱(前驱定义为小于x，且最大的数) 求x的后继(后继定义为大于x，且最小的数) INPUT第一行为n，表示操作的个数,下面n行每行有两个数opt和x，opt表示操作的序号(1&lt;=opt&lt;=6) OUTPUT对于操作3,4,5,6每行输出一个数，表示对应答案 SAMPLEINPUT101 1064654 11 3177211 4609291 6449851 841851 898516 819681 4927375 493598 OUTPUT10646584185492737 解题报告一道裸的平衡树板子题，也是我的Treap首题，留念123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0),f(1); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9')&#123; if(ch=='-') f=-1; ch=getchar(); &#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum*f;&#125;struct node&#123; int size,key,v; node *ch[2]; node():size(1),key(rand()),v(0)&#123; ch[0]=ch[1]=NULL; &#125; node(int x):size(1),key(rand()),v(x)&#123; ch[0]=ch[1]=NULL; &#125;&#125;*root;inline int get_size(node *x)&#123; if(x==NULL) return 0; return x-&gt;size;&#125;inline void pushup(node *rt)&#123; rt-&gt;size=get_size(rt-&gt;ch[0])+get_size(rt-&gt;ch[1])+1;&#125;inline void ro(node *&amp;rt,int d)&#123; node *tmp(rt-&gt;ch[d^1]); rt-&gt;ch[d^1]=tmp-&gt;ch[d]; pushup(rt); tmp-&gt;ch[d]=rt; pushup(tmp); rt=tmp;&#125;inline void insert(node *&amp;rt,int x)&#123; if(!rt)&#123; rt=new node(x); return; &#125; int d(rt-&gt;v&gt;x); insert(rt-&gt;ch[d^1],x); pushup(rt); if(rt-&gt;ch[d^1]-&gt;key&gt;rt-&gt;key) ro(rt,d);&#125;inline void del(node *&amp;rt,int x)&#123; if(rt-&gt;v==x)&#123; if(rt-&gt;ch[0]!=NULL&amp;&amp;rt-&gt;ch[1]!=NULL)&#123; int d(rt-&gt;ch[0]-&gt;key&gt;rt-&gt;ch[1]-&gt;key); ro(rt,d); del(rt-&gt;ch[d],x); &#125; else&#123; node *tmp=NULL; if(rt-&gt;ch[0]!=NULL) tmp=rt-&gt;ch[0]; else tmp=rt-&gt;ch[1]; delete rt; rt=tmp; &#125; &#125; else&#123; int d(rt-&gt;v&gt;x); del(rt-&gt;ch[d^1],x); &#125; if(rt!=NULL) pushup(rt);&#125;inline int rk(int x)&#123; node *rt(root); int ret(0); while(rt)&#123; if(x&gt;rt-&gt;v)&#123; ret+=get_size(rt-&gt;ch[0])+1; rt=rt-&gt;ch[1]; &#125; else rt=rt-&gt;ch[0]; &#125; return ret;&#125;inline int kth(int k)&#123; node *rt(root); while(rt)&#123; if(get_size(rt-&gt;ch[0])+1==k) return rt-&gt;v; if(get_size(rt-&gt;ch[0])+1&gt;k) rt=rt-&gt;ch[0]; else&#123; k-=get_size(rt-&gt;ch[0])+1; rt=rt-&gt;ch[1]; &#125; &#125; return 0;&#125;inline int gg()&#123; freopen("phs.in","r",stdin); freopen("phs.out","w",stdout); srand(time(NULL)); int n(read()); while(n--)&#123; int op(read()),x(read()); if(op==1)&#123; insert(root,x); continue; &#125; if(op==2)&#123; del(root,x); continue; &#125; if(op==3)&#123; printf("%d\n",rk(x)+1); continue; &#125; if(op==4)&#123; printf("%d\n",kth(x)); continue; &#125; if(op==5)&#123; printf("%d\n",kth(rk(x))); continue; &#125; if(op==6)&#123; printf("%d\n",kth(rk(x+1)+1)); continue; &#125; &#125;&#125;int k(gg());int main()&#123;;&#125; 玄学板子，调的时间比打的时间还长= =ps：参数类型一定要写对QWQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>各种平衡树，treap首题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JLOI2014]聪明的燕姿]]></title>
    <url>%2F2017%2F07%2F12%2F3%2F</url>
    <content type="text"><![CDATA[题目阴天傍晚车窗外未来有一个人在等待向左向右向前看爱要拐几个弯才来我遇见谁会有怎样的对白我等的人他在多远的未来我听见风来自地铁和人海我排着队拿着爱的号码牌城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于S所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。（莫名唱了起来= =） INPUT输入包含k组数据（k&lt;=100）对于每组数据，输入包含一个号码牌S(S&lt;=10^9) OUTPUT对于每组数据，输出有两行，第一行包含一个整数m，表示有m个等的人，第二行包含相应的m个数，表示所有等的人的号码牌。注意：你输出的号码牌必须按照升序排列。 SAMPLEINPUT42 OUTPUT320 26 41 解题报告考试的时候，一看就知道A不了，打了个极其暴力的程序= =1234567891011inline void find(long long x)&#123; int ret(0); for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0) ret+=i,ret+=x%i; if(i*i==x) ret-=i; &#125; if(ret==s) ans++;&#125; 结果显然= =正解则是个很神奇的东西唯一分解定理：任何大于１的自然数，都可以唯一分解成有限个质数的乘积即：n=p1^k1×p2^k2…×pa^ka那么何不预处理出来一大圈质数，然后dfs出唯一分解式呢n=p1^k1×p2^k2..×pa^ka因数和即可表示成（p1+p1^2+…+p1^k1）…那么我们就可以dfs了（我实在不会数学啊QAQ）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef long long L;L s;L prime[100001],num_prime(0);bool flag[100001];inline void play_table()&#123; memset(flag,true,sizeof(flag)); flag[0]=flag[1]=false; for(int i=2;i&lt;100000;i++)&#123; if(flag[i]) prime[++num_prime]=i; for(int j=1;j&lt;=num_prime&amp;&amp;prime[j]*i&lt;100000;j++)&#123; flag[i*prime[j]]=false; if(i%prime[j]==0) break; &#125; &#125;&#125;L ans[1000001],top(0);int ppp[4]=&#123;2,3,5,7&#125;;/*inline int modular_exp(int a,int m,int n)&#123; if(m==0) return 1; if(m==1) return a%n; L w(modular_exp(a,m&gt;&gt;1,n)); w=w*w%n; if(w&amp;1) w=w*a%n; return w;&#125;inline bool check(L x)&#123; if(x==2||x==3||x==5||x==7) return true; for(int i=0;i&lt;4;i++) if(modular_exp(ppp[i],x,x)!=ppp[i]) return false; return true;&#125;*/inline bool check(L x)&#123; for(int i=1;prime[i]*prime[i]&lt;=x;i++) if(x%prime[i]==0) return false; return true;&#125;inline void dfs(L st,L pos,L now)&#123; if(st==1)&#123; ans[++top]=now; return; &#125; if((st-1)&gt;prime[pos]&amp;&amp;check(st-1)) ans[++top]=now*(st-1); for(int i=pos+1;prime[i]*prime[i]&lt;=st;i++)&#123; L t(1),al(1); for(int j=1;t&lt;=st;j++)&#123; al*=prime[i]; t+=al; if(st%t==0) dfs(st/t,i,now*al); &#125; &#125;&#125;int main()&#123; play_table(); while(scanf("%lld",&amp;s)==1)&#123; top=0; dfs(s,0,1); sort(ans+1,ans+top+1); printf("%lld\n",top); for(int i=1;i&lt;top;i++) printf("%lld ",ans[i]); if(top!=0) printf("%lld\n",ans[top]); &#125;&#125; ps：本来想打Miller-Rabin的，然后就gg了QAQ]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学 暴搜？？？</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2008]假面舞会]]></title>
    <url>%2F2017%2F07%2F12%2F2%2F</url>
    <content type="text"><![CDATA[题目一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面 具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为k (k≥3)类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第i 类面具的人才能看到戴第i+1 类面具的人的编号，戴第k 类面具的人能看到戴第1 类面具的人的编号。参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第2号面具的人看到了第5 号面具。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了k≥3，所以你必须将这条信息也考虑进去。 INPUT输入文件第一行包含两个整数n, m，用一个空格分隔，n 表示主办方总共准备了多少个面具，m 表示栋栋收集了多少条信息。接下来m 行，每行为两个用空格分开的整数a, b，表示戴第a 号面具的人看到了第b 号面具。相同的数对a, b 在输入文件中可能出现多次。 OUTPUT输出文件包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。如果无法将所有的面具分为至少3 类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个-1。 SAMPLEinput 1st6 51 22 33 44 13 5 output 1st4 4 input 2nd3 31 22 12 3 output 2nd-1 -1 解题报告当时考试的时候，一看这种带顺序的类似图论的奇怪东西，就想到了拓扑排序然后……并不会打拓扑啊QAQ，于是打了个奇（chun）奇（dao）怪（bao）怪（zha）的dfs，好像拿了个特判的-1 -1的分QAQ正解仍然是dfs由题目可知，从一个点连出去的点标号一样，几个点指向同一个点，标号也肯定一样。而且，有一句很重要的话： 戴第k 类面具的人能看到戴第1 类面具的人的编号。那么如果我们找到了环，并将所有环的GCD找出来，我们就找到了最大值。正确性显然= =如果没有环呢？显然我们还可以找到链，而链则不会受到上面那个条件的制约，我们就可以很轻松的解决这个问题啦。然而我们似乎忘记了一个很神奇的东西= =当我们遇到有各种方向边的环时，显然通过上面的证明，会有第一个点有多个不同标号的情况，这是不可能的，所以，只能看作是不停的由第k个点看第一个点的特殊情况。如何处理？很简单，设某个方向边组成的那半个环为ax+k=b的循环，另一个方向边组成的那半个环为cx+k=b的循环。（这里的循环指从第一个点一直走到第k个点再走回第一个点）。显然环是要一样大的，而多出n个环数的点数也应是一样大的（不然起点或终点就会有不止一个标号）。所以，我们只需建双向边,正边权值1，反边权值-1，最后取个绝对值，就可当正常环看待了（正确性显然= =）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int sum(0); char ch(getchar()); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9')&#123; sum=sum*10+ch-'0'; ch=getchar(); &#125; return sum;&#125;struct edge&#123; int s,e,n,w;&#125;a[2000001];int pre[100001],tot;inline void insert(int s,int e,int w)&#123; a[++tot].s=s; a[tot].e=e; a[tot].w=w; a[tot].n=pre[s]; pre[s]=tot;&#125;inline void swp(int &amp;a,int &amp;b)&#123; a^=b; b^=a; a^=b;&#125;/*inline int gcd(int a,int b)&#123; //cout&lt;&lt;a&lt;&lt;' '&lt;&lt;b&lt;&lt;endl; if(a==0) return b; if(b==0) return a; int i,j; for(i=0;0==(a&amp;1);i++) a&gt;&gt;=1; for(j=0;0==(b&amp;1);j++) b&gt;&gt;=1; if(j&lt;i) i=j; while(1)&#123; if(a&lt;b) swp(a,b); if(0==(a-=b)) return b&lt;&lt;i; while(a&amp;1) a&gt;&gt;=1; &#125;&#125;*/inline int gcd(int a,int b)&#123; if(a==0) return b; if(b==0) return a; return a%b?gcd(b,a%b):b;&#125;inline int jdz(int x)&#123; return x&gt;=0?x:-x;&#125;inline int my_min(int a,int b)&#123; return a&lt;b?a:b;&#125;inline int my_max(int a,int b)&#123; return a&gt;b?a:b;&#125;int n,m;bool vis[100001]=&#123;0&#125;;int f[100001]=&#123;0&#125;;int mx,mn;int circle(0),ans(0);inline void dfs(int u,int cnt)&#123; if(vis[u]) return; f[u]=cnt;vis[u]=1; mx=my_max(mx,cnt); mn=my_min(mn,cnt); for(int i=pre[u];i!=-1;i=a[i].n)&#123; int e(a[i].e); if(vis[e])&#123; int cir(jdz(cnt-f[e]+a[i].w)); if(cir)&#123; if(circle==0) circle=cir; else circle=gcd(circle,cir); &#125; &#125; else dfs(e,cnt+a[i].w); &#125;&#125;int main()&#123;// freopen("party2008.in","r",stdin);// freopen("party2008.out","w",stdout); memset(pre,-1,sizeof(pre)); n=read(),m=read(); for(int i=1;i&lt;=m;i++)&#123; int x(read()),y(read()); insert(x,y,1); insert(y,x,-1); &#125; for(int i=1;i&lt;=n;i++) if(!vis[i])&#123; mx=-0x7fffffff; mn=0x7fffffff; dfs(i,0); ans+=mx-mn+1; &#125; if(circle==0)&#123; if(ans&lt;3)&#123; printf("-1 -1"); return 0; &#125; else&#123; printf("%d %d",ans,3); return 0; &#125; &#125; else&#123; if(circle&lt;3)&#123; printf("-1 -1"); return 0; &#125; else&#123; printf("%d ",circle); int gg(0); for(int i=3;i&lt;=circle;i++)&#123; if(circle%i==0)&#123; gg=i; break; &#125; &#125; if(gg==0) printf("%d",circle); else printf("%d",gg); &#125; &#125;&#125; ps：一直在WA，最后发现是GCD打错了= =pss：听取蛙声一片啊= =]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F2017%2F07%2F11%2F1%2F</url>
    <content type="text"><![CDATA[hello world first article123456#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello world!"; return 0;&#125; It’s interesting,isn’t it?12PRINT "My name is Mafia"END but what is OI to me?123456789#include&lt;iostream&gt;using namespace std;typedef unsigned long long L;L s(1);int main()&#123; for(L i=1;i&lt;=???;i++) s*=i; cout&lt;&lt;"The importance of OI is"&lt;&lt;s;&#125; and I love programming!12PRINT "DO IT NOW!"END to be continued…]]></content>
  </entry>
</search>